<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[CS61B-8:Hashing]]></title>
    <url>%2F2019%2F07%2F30%2FCS61B-8%2F</url>
    <content type="text"><![CDATA[Hashing Issue with the Former Data Structure 1. Items need to be comparable 2. Can do better than θ(logN) Data Indexed Integer Set Improve complexity from θ(logN) to θ(1) Implementation Constructor: large ArrayList of type boolean add(int x): set x position to true contains(int x) return whether x position is true potential issues ☑️wasteful space ☑️insertions of other type Data Indexed Word Set Big Idea String =(map)=&gt; some Integer =&gt; Data Indexed Integer Set App #1 - Use the first letter Collision: two different inputs mapped to the same one App #2 – Avoiding Collisions String to unique Base26 Integers &emsp;&emsp;e.g. “cat” = 3*26*26 + 1*26 + 20*1 = 2074 ☑️Still wasteful of memory ☑️Overflow if support Strings beyond single English words Hash Codes - Take an object and convert it into some integer App #1 - Default .hashCode() method using memory address of object App #2 - Write our own hashcode method Properties of HashCodes 1. Must be an integer 2. .hashCode() return the same number each time 3. Two objects that are .equal() must have the same hash code Good hashCode distribute items evenly Collision Handling Solution: array contain a LinkedList of items instead of just items Implementation Nothing at index create a new LinkedList, place it and add new item Index Already taken simply add item to list No duplicate keys =&gt; must check if key exist already Insert to the end of list =&gt; have to check all the elements anyways Workflow add item get hashcode of item if index has no item =&gt; create new list and place item there if already a list =&gt; check if the key exists and add item to list contains item get hashcode of item if index is empty =&gt; flase otherwise, check all items in the list at that index Runtime complexity of worst case contains - θ(Q): have to look at all items in list add - θ(Q): have to make sure the item not in the list yet Space solving Modulo – hashcode % size of ArrayList LinkedList expected to be longer HashTable Workflow Input =&gt; hashcode =&gt; modulus to get index Dynamically growing our hashtable M buckets and N items =&gt; Load Factor L = N/M Solution – Set load factor threshold Create a new HashTable with 2M buckets Iterate thru all items in the old HashTable, add them into new HashTable (modulus changes =&gt; may into different buckets) Runtime Complexity add and contains &emsp;&emsp;θ(L)= θ(1) =&gt; assuming items evenly distributed Resizing &emsp;&emsp;Already know no duplicates =&gt; add to the front of LinkedList &emsp;&emsp;Overall θ(N) =&gt; each items need θ(1) Improve our hashcodes Giving random values for different items =&gt; evenly distributed Strategies Use a base strategy in which the base is a prime ☑️Too small =&gt; String with small length spread within small ranges ☑️Too big =&gt; Caused by collision due to overflow &emsp;&emsp;e.g. base126 (string with same last 32 chars =&gt; same hashcode) Heaps and Priority Queue Priority Queue Interface12345678910111213/** (Min) Priority Queue: Allowing tracking and removal of * the smallest item in a priority queue. */public interface MinPQ&lt;Item&gt; &#123; /** Adds the item to the priority queue. */ public void add(Item x); /** Returns the smallest item in the priority queue. */ public Item getSmallest(); /** Removes the smallest item from the priority queue. */ public Item removeSmallest(); /** Returns the size of the priority queue. */ public int size();&#125;]]></content>
      <categories>
        <category>CS61B</category>
        <category>Lecture Notes</category>
      </categories>
      <tags>
        <tag>hashing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS61B-7:Balanced Search Tree, B-Tree, Rotating Tree, Red-Black Tree]]></title>
    <url>%2F2019%2F07%2F29%2FCS61B-7%2F</url>
    <content type="text"><![CDATA[Balanced Search Tree Intro Runtime: Worst Case vs. Best Case Worst case: θ(N) – spindly tree (equivalently LinkedList) Best case: θ(logN) (N is number of nodes) – bushy tree BST Performance Terminology Depth – number of links between a node and root Height – lowest depth of a tree Average Depth – average of the total depths in the tree Performance Factors Height =&gt; worst-case runtime Average depth =&gt; average-case runtime BST insertion order =&gt; determine height Random order Resulting tree is relatively bushy Average depth and height expected to be θ(logN) B-Tree (2-3-4 Tree/2-3 Tree) Intro Root of spindly tree Always insert at a leaf node =&gt; height increase Fix #1 Never add leaf node =&gt; add to current leaf node Problem =&gt; still need to scan thru almost all nodes =&gt; θ(N) &emsp; Fix #2 – Split node in half Set a limit on the number of elements in a single node &emsp; 2-3 Tree / 2-3-4 Tree (BTree)2-3 Tree splits when they have 2 nodes and one more needs to be added2-3 Tree means the number of children each node can have Insertion Process of 2-3-4 Tree1. Always insert into a lead node.2. After adding to the leaf, if new node has 4 nodes =&gt; pop up the middle left node and rearrange the children accordingly3.If results in 4-node parents=&gt; pop up the middle left node again4.Repeat till the parent node can accommodate or you get to the root B-Tree Invariants and Runtime Invariants All leaves must be the same distance from the source Non-leaf node with k items must have k+1 children Order of insertion changes height of tree but tree always bushy &emsp;&emsp;e.g. 1,2,3,4,5,6,7 or 2,3,4,5,6,1,7 Runtime Analysis Worst case 1. # of element in node L reaches maximum 2. Have to traverse to the bottom RuntimeMax logN height =&gt; O(L* logN) =&gt; O(logN) Rotating Trees Tree Rotation (x is the child of G) rotateLeft(G)Let x.left be the right child of G. Make G the new left child of x rotateRight(G)Let x.right be the left child of G. Make G the new right child of x Non-root nodeDisconnect the root and rotate, then reconnect to the new root 123456789101112131415Private Node rotateRight(Node h) &#123; // assert (h != null) &amp;&amp; isRed(h.left) Node x = h.left; h.left = x.right; x.right = h; return x;&#125;// make a right-leaning link lean to the left Private Node rotateLeft(Node h) &#123; // assert (h != null) &amp;&amp; isRed(h.right); Node x = h.right; h.left = x.right; x.left = h; return x;&#125; Red-Black Trees From 2-3 Tree to BST No modification for 2-3 tree with 2 nodes 2-3 tree with 3 nodesCreate a glue node for 2-item node =&gt; waste space / ugly code&emsp; Left-Leaning Red-Black Tree (LLRB) Use glue links instead of glue node (made red) Make the left element a child of the right one LLRB has 1-1 correspondence with 2-3 trees &emsp; Properties of LLRB 1-1 correspondence with 2-3 trees No node has 2 red links (violation of 2-3 tree) No red right-links Each path from root to leaf has the same # of black links Height is no more than 2x height of corresponding 2-3 tree Insertion into LLRB Big IdeaInsert as normal BST and use rotations the massage tree back into proper structure Task1: Insertion color Always insert into leaf node =&gt; always red Task2: Insertion on the right – left leaning violation No red right links =&gt; rotate if insert on the right&emsp; Temporarily allows right insertion when the left link also red&emsp; Task3: Double Insertion on the Left – Incorrect 4 Node Violation Two left red links =&gt; rotateRight to get the temporarily violating tree&emsp; Flip colors of all edges touching the node to which red links connect&emsp; May need to go thru a series of rotations to complete transformation Summary of Insertion When inserting =&gt; like normal BST / use a red link Left Leaning Violation =&gt; rotate left 4 Node Violation =&gt; rotate right Temporary 4 Node =&gt; flip the color Runtime LLRB remains within 2x the height of its 2-3 tree =&gt; logN 1234567891011private Node put(Node h, Key key, Value, val) &#123; if (h == null) &#123;return new Node(key, val, RED);&#125; int cmp = key.compareTo(h.key); if (cmp &lt; 0) &#123;h.left = put(h.left, key, val);&#125; else if (cmp &gt; 0) &#123;h.right = put(h.right, key, val);&#125; else &#123;h.val = val&#125; if(isRed(h.right) &amp;&amp; !isRed(h.left)) &#123;h = rotateLeft(h);&#125; if(isRed(h.left) &amp;&amp; isRed(h.left.left)) &#123;h = rotateRight(h);&#125; if(isRed(h.right) &amp;&amp; isRed(h.left)) &#123;flipColors(h);&#125; return h;&#125; Reference:&emsp;berkeyley-cs61b]]></content>
      <categories>
        <category>CS61B</category>
        <category>Lecture Notes</category>
      </categories>
      <tags>
        <tag>Balanced Search Tree</tag>
        <tag>B-Tree</tag>
        <tag>2-3-4 Tree</tag>
        <tag>2-3 Tree</tag>
        <tag>Rotating Tree</tag>
        <tag>Red-Black Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS61B-6:Disjoint Set, Binary Search Tree]]></title>
    <url>%2F2019%2F07%2F21%2FCS61B-6%2F</url>
    <content type="text"><![CDATA[Disjoint Set Introduction to Disjoint Set Disjoints sets: two sets having no elements in common connect(x, y): connect x and y, known as union isConnect(x, y): returns true if x and y are connected 123456public interface DisjointSets &#123; /** connects two items P and Q */ void connect(int p, int q); /** checks to see if two items are connected */ boolean isConnected(int p, int q); &#125; ListSet As a List of sets e.g. List&lt;Set&gt; connect(x, y) will be O(N) (iterate all sets to find x and y) Quick Find Using single array of integers Indices – element of our set Value – set number connect(x, y) All the element with set id of x and y should share the same id runtime θ(N) isConnected(x, y)simply check id[x] == id[y] =&gt; constant time θ(1) Quick Union Assign each item the index of its parent If item has no parent (root), assign it a negative value Need a find(item x) helper function (return the root of tree) connect(x, y) find each item’s set, make one the child of the other best case (x and y both roots) -&gt; θ(1) isConnected(x, y) check if find(x) == find(y) Performance Spindly tree =&gt; finding items is expensive in worst case Bushy tree =&gt; perform well Weighted Quick Union (WQU) New Rule - link the root of the smaller tree to the lager tree Tree has a maximum height of logN Definition of smaller/larger : number of items in a tree (Weighted) Can store the size of the tree as the root items value Runtime Proof For any item x in tree T1, if T1 placed below another tree T2, &emsp;&emsp;Then depth(x) ++ and size(resulting tree) &gt;= 2 * size(T1) Maximally log2N times of doubling of trees for N items Weighted Quick Union with Path Compression Path Compression When calling find(x), we traverse the path from x to root, but along the way we can connect all the items as we visited to their root at no extra asymptotic cost =&gt; make tree shorter Runtime By calling find(x) enough, all elements will point to root In the long term, the runtime will become almost constant For M operations on N items, will be O(N + M(lg*N)) Summary of Disjoint Set Runtime Binary Search Tree (BST) From Sorted Linked List to Tree Ordered Linked List – slow key search O(N) Potential Optimization: skip list – add extra links Improvement #1: Change Entry Point to middle and Flip Left Links Improvement #2: Add Pointers to Middle of Each Recursive Half (Tree) Tree Tree Component Nodes Edges that connect those nodes (exactly one path between any 2 nodes) Terminology Root: node without parents Leaves: nodes without children Binary Tree Binary Property: each node with either 0, 1, 2 children Binary Search Tree (BST) BST Property For each node X in the tree: &emsp;&emsp;Every key in the left subtree is less than X’s key &emsp;&emsp;Every key in the right subtree is greater than X’s key No duplicate allowed Operations #1: Search if searchKey == root, return if searchKey &lt; root, Search left subtree if searchKey &gt; root, Search right subtree Repeat until either find the key or no key appears here Runtime will be θ(logN) for the bushy tree Operations #2: Insert Search key in the tree &emsp;&emsp; Do nothing if found &emsp;&emsp; Will be at leaf node if not, just add new element to the position Operations #3: Delete Case #1: no children Delete its parent pointer and node will be garbage collected Case #2: one child Assign its parent’s child pointer to this node’s child Case #3: two children – Hibbard deletion Replace the deleted node with either: &emsp;&emsp; right-most node in the left subtree &emsp;&emsp; left-most node in the right subtree Then delete the node used to replace the deleted node (case 1 or 2) Reference:&emsp;berkeyley-cs61b]]></content>
      <categories>
        <category>CS61B</category>
        <category>Lecture Notes</category>
      </categories>
      <tags>
        <tag>Disjoint Set</tag>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS61B-5:Asymptotics, Binary Search, Amortized Analysis]]></title>
    <url>%2F2019%2F07%2F18%2FCS61B-5%2F</url>
    <content type="text"><![CDATA[Efficient Programming Efficiency Programming Cost Develop programs Read, modify and maintain code Execution cost Time Complexity Space Complexity Encapsulation Module – set of methods performing some tasks Encapsulated – implementation completely hidden, Accessed by APIs APIs (Application Programming Interface) The list of constructors and methods and a short description of each Syntactic (syntax) and semantic (test) specification ADTs (Abstract Data Structures) High - level types defined by behaviors, not implementations Extension vs. Delegation &emsp;Extension – extends class (when know implementation of parent class) &emsp;&emsp;e.g. Stack extends LinkedList &emsp;Delegation – pass object in another class and use its methods &emsp;&emsp;e.g. instantiate or pass a LinkedList into Stack class Measuring Computational Cost ApproachesApp #1: measure execution time in seconds using a client programApp #2A: count possible operations for array size N = 1000App #2B: count possible operations for array size N (symbolic counts) Asymptotic behaviorWell-scaling algorithms have better asymptotic runtime behaviorOrder of growth == shape of graph Simplifications#1: Consider only the Worst Case#2: Restrict Attention to One Operation (Representative) – cost model#3: Eliminate Lower Order Terms#4: Eliminate Multiplicative Constants Binary Search (require list to be in sorted order) Algorithm Problem: Find a key in a sorted array 1.Compare key against middle entry 2.key is smaller =&gt; left // bigger =&gt; right // equal =&gt; find key RunTime problem size halves over and over till it gets down to 1 Worst case =&gt; key is not in the list at all =&gt; Log(N) Exact Count Analysis C(N) = floor(log2(N)) + 1 One Tiny Bug12mid = (low + high) / 2 // can cause overflowmid = low + (high - low) / 2 // no overflow Merge Sort AU (Arbitrary Units of Time) Merging Operation – combine two sorted arrays into a big sorted array Put the min(arr1, arr2) to the start and repeat Runtime ⊖(N) First ThoughtSelection Sort of N = 64: ~2048 AUSS (half) and Merge of N = 64: ~(512 * 2 + 64)The latter is faster but still ⊖(N) Merge Sort AlgorithmHalves until list size is 1 (no need for SS due to size 1)12345678910mergeSort(array) &#123; If (size == 1) &#123; return; &#125; mergeSort(array.leftHalf); mergeSort(array.rightHalf); merge(array.leftHalf, array.rightHalf); return;&#125; Runtime AnalysisEach layer takes N AUThe number of layer is k = log2(N)The overall runtime in the worst case is ⊖(N*logN) Big Theta, Big O and Big Omega Big Theta – representing the families =&gt; order of growthBoth upper and lower bounded =&gt; runtime equality Big O – upper bound =&gt; less than or equal Why useful?1. If the runtime depends on more than N&emsp;&emsp;=&gt; must qualify statement before using big theta2. for tricky problems, cannot know exact runtime&emsp;&emsp;=&gt; give upper bound3. easier to write proofs than big theta Big O abuseThe worst case runtime is ⊖(N^2) =&gt; provide more informationThe runtime is O(N^2) =&gt; avoid qualifying statementsBig O is NOT the same as worst case Big Omega – lower bound =&gt; greater than or equal Use of Big Omega1.Prove Big Theta. R(N)= O(f(N))= Ω(f(N)) =&gt; R(N)= ⊖(f(N))2.Prove difficulty of problems. E.g. dup-finding algorithm must be Ω(N) Summary Amortized Analysis Preview Grigometh’s Tribute Two PaymentsChoice#1: eat 3 bushels of hay each dayChoice#2: eat exponentially more hay but come exponentially less often&emsp;&emsp;Day1, eat 1 bushel of hay (total 1)&emsp;&emsp;Day2, eat 2 bushel of hay (total 3)&emsp;&emsp;Day4, eat 4 bushel of hay (total 7)Payment: putting 3 bushels of hay each day satisfies both.Choice#2 is as amortized constant hay consumption AList Resizing and Amortization Geometric resizing is similar to Grigometh’s tribute Most add operations are cheap while some are expensive On average, the runtime of add is ⊖(1) Amortized Analysis Steps of Amortized Analysis1. Pick a cost model2. Compute the average cost of ith operation3. Show that average cost is bounded by a constant Example – Geometric Resizing Potential $ϕ_i= ϕ_{i-1}+a_i-c_i$☑️Initial potential be 0☑️Can take $a_i$ as deposit and $c_i$ as withdrawal☑️If we can choose constant $a_i$ such that $ϕ_i$ is never negative, then the amortized cost is an upper bound on the true cost =&gt; average constant time Reference:&emsp;berkeyley-cs61b]]></content>
      <categories>
        <category>CS61B</category>
        <category>Lecture Notes</category>
      </categories>
      <tags>
        <tag>Asymptotics</tag>
        <tag>Binary Search</tag>
        <tag>Amortized Analysis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-Dynamic Programming]]></title>
    <url>%2F2019%2F07%2F17%2FLeetCode-Dynamic-Programming%2F</url>
    <content type="text"><![CDATA[#123 Best Time to Buy and Sell Stock IIIInput is an array for which the ith element is the price of a given stock on day i.Find the maximum profit. You may complete at most two transactions.Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again). Example 1:Input: [3,3,5,0,0,3,1,4]Output: 6Explanation: Buy on day 4 (price = 0), sell on day 6 (price = 3), profit = 3-0 = 3.Then buy on day 7 (price = 1), sell on day 8 (price = 4), profit = 4-1 = 3. This is a hard-level problem on the LeetCode, which takes me much time to think about. Thus, I’d like to write this post to review this problem. Basically, we can imagine this as two separate purchase-selling process, i.e. [first buy …. first sell] [second buy …. second sell]. It is worth noting that second buy happens only after the first sell. In this way, we can turn this two processes into one-time purchase-selling process which the price on i-th day takes the maximum profits before day i into account.&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;$newPrices[i] = prices[i] - maximum\ Profit\ of\ first\ buy$Using dynamic programming algorithm, the implementation is shown as below. 12345678910111213141516171819202122232425class Solution &#123; public int maxProfit(int[] prices) &#123; if (prices == null || prices.length &lt;= 1) &#123; return 0; &#125; int maxProfit = 0; int minCost = prices[0]; int[] dp = new int[prices.length]; dp[0] = prices[0]; // compute the newPrice and store the record in dp[] for (int i = 1; i &lt; prices.length; i++) &#123; minCost = Math.min(minCost, prices[i]); maxProfit = Math.max(maxProfit, prices[i] - minCost); dp[i] = prices[i] - maxProfit; &#125; maxProfit = 0; minCost = prices[0]; // find the max profit as you only buy once for (int i = 0; i &lt; prices.length; i++) &#123; minCost = Math.min(minCost, dp[i]); maxProfit = Math.max(maxProfit, prices[i] - minCost); &#125; return maxProfit; &#125;&#125; The above implementation takes two pass. However, if we look a little deeper, we can find that the two pass can actually be combined as one like below. 123456789101112131415class Solution &#123; public int maxProfit(int[] prices) &#123; int sell1 = 0; // maximum profit after first sell int sell2 = 0; // total maximum profit after second sell int buy1 = Integer.MAX_VALUE; int buy2 = Integer.MAX_VALUE; for (int i = 0; i &lt; prices.length; i++) &#123; buy1 = Math.min(buy1, prices[i]); sell1 = Math.max(sell1, prices[i] - buy1); buy2 = Math.min(buy2, prices[i] - sell1); sell2 = Math.max(sell2, prices[i] - buy2); &#125; return sell2; &#125;&#125; Well, I think the above approach is the most compact way to solve this while I think there are other perspectives to look at this problem. For instance, using DP, you can build two arrays, one to store the maximum profit of one buy-sell before day i and one for after day i. We just find the Max(Sum(two arrays)) to solve this problem. #213 - House RobberIIYou are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. ExampleInput: [2,3,2]Output: 3Explanation: You cannot rob house 1 (money = 2), then rob house 3 (money = 2),because they are adjacent houses. That it the #213 problem in the LeetCode. However, to solve this problem, let’s first review the easy-version of this problem, #198 in the LeetCode in which all the houses are arranged as a line but not a circle. These two are typical dynamic programming problems. For #198, imgaine that we have robbed i - 1 houses and come in the front of the i-th house. Now we need to decide if we should rob this one. But How ? It turns out that whether we rob the house i depends on two values, the total profit of robbing house i and the totoal profit of not robbing house i before coming to house i + 1. $Total\ Profit\ Of\ Robbing\ i = Total\ Profit\ Of\ Robbing\ (i-2) + Profit\ Of\ Robbing\ i$$Total\ Profit\ Of\ Not\ Robbing\ i = Total\ Profit\ Of\ Robbing\ (i-1)$ We choose the larger one and come to the next house. The code is shown as below. 12345678910111213141516171819class Solution &#123; public int rob(int[] nums) &#123; if (nums == null || nums.length == 0) &#123; return 0; &#125; if (nums.length == 1) &#123; return nums[0]; &#125; int lastHouse = nums[0] &gt; nums[1] ? nums[0] : nums[1]; int lastTwo = nums[0]; int maxProfit = lastHouse; for (int i = 2; i &lt; nums.length; i++) &#123; maxProfit = Math.max(lastTwo + nums[i], lastHouse); lastTwo = lastHouse; lastHouse = maxProfit; &#125; return maxProfit; &#125;&#125; Well, now let’s get back to the #213. The only difference here is that houses are arranged in a circle right now. The key here is that the start house and end house cannot be robbed at the same night. So, either you don’t rob start house or you don’t rob end house. Assume that for some strange reasons, you don’t want to rob the start house, then you are allowed to rob the last one. Actually this case is just like the situation where the start house does not appear in the array. Similarly, if you choose not to rob the last one, the case is just like that the last house does not appear in the array. Thus, the answer is just the maximum money of the two cases. The implementation is shown as below. 12345678910111213141516171819202122232425262728class Solution &#123; public int robHelper(int[] nums, int start, int end) &#123; if (start &gt; end) &#123; return Integer.MIN_VALUE; &#125; if (start == end) &#123; return nums[start]; &#125; int lastHouse = nums[start] &gt; nums[start + 1] ? nums[start] : nums[start + 1]; int lastTwo = nums[start]; int maxProfit = lastHouse; for (int i = start + 2; i &lt;= end; i++) &#123; maxProfit = Math.max(lastTwo + nums[i], lastHouse); lastTwo = lastHouse; lastHouse = maxProfit; &#125; return maxProfit; &#125; public int rob(int[] nums) &#123; if (nums == null || nums.length == 0) &#123; return 0; &#125; if (nums.length == 1) &#123; return nums[0]; &#125; return Math.max(robHelper(nums, 0, nums.length - 2), robHelper(nums, 1, nums.length - 1)); &#125;&#125; #221 Maximal SquareGiven a 2D binary matrix filled with 0’s and 1’s, find the largest square containing only 1’s and return its area. Example: Input:$1\ 0\ 1\ 0\ 0$$1\ 0\ 1\ 1\ 1$$1\ 1\ 1\ 1\ 1$$1\ 0\ 0\ 1\ 0$ Output: 4 Yet another DP problem today. This problem expects us, in short, to find the maximal square with all 1’s in the matrix. Suppose now we are up to the element matrix[i][j] and the element is 1. Now we get 2 paths. One is that the new element can combine its adjacent elements to make a bigger square or they can not. So how could we decide which one of the above path to take? Now we just pretend that we could take the former one, and the newly generated square is m x m large. Ok, now we know that up till the element matrix[i][j], we can get a square whose side length is m. If we record the maximal side length of square with the element[i][j] as the bottom right points for each element as dp[i][j], then we know, dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1. Actually, the three values dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1] limits the three other vertex of the square. This is a dynamic programming way solution to this problem. To analyze, the time complexity of this way is O(mn) and the space complexity is also O(mn). Well, can we do better? Sure, notice that when we compute the dp, we only care about the previous element to this position and (i - 1)th row. That is to say, we do not need a matrix to store dp at all. Instead, we only need a 1D array for dynamic programming, then the space complexity can become O(n).]]></content>
      <categories>
        <category>LeetCode</category>
        <category>dynamic programming</category>
      </categories>
      <tags>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS61B-4:Autoboxing & Widening, Immutability, Generic Methods & Type Upper Bounds, Exception, Iteration, Object Methods, Package & Access Control]]></title>
    <url>%2F2019%2F07%2F08%2FCS61B-4%2F</url>
    <content type="text"><![CDATA[Generics and Autoboxing Automatic Conversions Autoboxing and UnboxingCannot provide primitive type as an actual type argumentUse corresponding reference type (wrapper classes)Java implicitly convert between primitive and wrapper typesArrays are never auto-boxed or auto-unboxed&emsp;&emsp;e.g. Integer[] x = (int[]) x; (compiler not allowed)autoboxing and unboxing has a measurable performance impact wrapper types use much more memory than primitive types&emsp;&emsp;every object has a 64 bit refetrence variable and requires 64 bits of&emsp;&emsp;overhead to store things like the dynamic type of the object WideningJava automatically widen a primitive if neededVariable of type T1 will be implicitly cast to type T2 which takes a wider range of values than T1 (e.g. int =&gt; double)Have to manually cast when going from a wider type to a narrower type&emsp;&emsp;e.g. double x = 20; int y = (int) x; Immutabilityimmutable data type: cannot change in any observable way after instantiation&emsp;&emsp;e.g. String =&gt; remain unchanged after calling any method on Stringany data type with non-private variables is mutable unless declared final(final: prevent the variable from being changed after first assignment) Prosprevent bugs and makes debugging easier (properties cannot change)can count on objects to have a certain behavior/trait Consneed to create a new object in order to change a propertyDeclare a reference as final does not make the object that reference is pointing to immutableReflection API possibly change even the private variables Generics - Maps&lt;K, V&gt; Compilation error: assertEquals ambiguous 1234ArrayMap&lt;Integer, Integer&gt; am = new ArrayMap&lt;&gt;();am.put(2,5);int expected = 5;assertEquals(expected, am.get(2)); This is because assertEquals is overloaded, e.g. assertEquals(int expected, int actual), assertEquals(Object expected, Object actual) =&gt; Java does not know which method to call. Generic Methodsgenerics defined in class header (share with all methods) =&gt; Java wait for user to instantiate an object of the class in order to know the actual type ☑️Declare method as generic 1public static &lt;K, V&gt; V get(Map61B&lt;K, V&gt; map, String key) &#123;...&#125; The only issue here is that for maxKey(Map61B), “&gt;”operator only works for primitive. Then we can think of using .compareTo() method instead. But ! not all objects have .compareTo() method. Here, we declare it as K extends Comparable, this means that keys must implement the comparable interface. In the end we declare this method as below. 1public static &lt;K extends Comparable&lt;K&gt;, V&gt; V get(Map61B&lt;K, V&gt; map, String key) &#123;...&#125; ☑️Type Upper Bounds Extends in the above context simply states a fact that K must be a Comparable instead of giving K the abilities of a Comparable Summary of genericsAutoboxing and auto-unboxingPromotion/Widening between primitive typesGeneric types for methods (before return type)Type upper bounds in generic methods ExceptionsException breaks normal flow of control, handling error. Throw ExceptionsExceptions are objects in Javathrow new ExceptionObject(para1,…) Catching Exceptionstry and catch breaks the normal flow of the program&emsp;&emsp;protect program from exceptions&emsp;&emsp;corrective action&emsp;&emsp;keep error handling separate from the rest of the program 12345678910111213141516171819func readFile: &#123; try &#123; open the file; determine its size; allocate that much memory; read the file into memory; close the file; &#125; catch (fileOpenFailed) &#123; doSomething; &#125; catch (sizeDeterminationFailed) &#123; doSomething; &#125; catch (memoryAllocationFailed) &#123; doSomething; &#125; catch (readFailed) &#123; doSomething; &#125; catch (fileCloseFailed) &#123; doSomething; &#125;&#125; Uncaught ExceptionsException thrown =&gt; descends the call stack =&gt; bottom of the stack =&gt; crash and print out the stack trace Checked vs. Unchecked Exceptions Compilation ErrorException must be caught or declared to be thrown&emsp;=&gt; Compiler thinks some exceptions must be handled Checked ExceptionsMust be handled2 ways to handle checked error&emsp;Catch: handle it right now&emsp;Specify: defer handling &amp; mark methods as dangerous 123456public static void dangerMethod() throws IOException &#123;…&#125;public static void main (String[] args) &#123; // main method is also dangerous by calling gulgate // handle it by try-catch or specifying gulgate()&#125; Unchecked Exceptions Not need to be handle and compile just fine but may crash at runtime Include Error &amp; RuntimeException (unknown till runtime &amp; unrecoverable) Iteration Enhanced For Loop 12345Set&lt;String&gt; s = new HashSet&lt;&gt;();...for (String city : s) &#123;...&#125; The above code translate to 1234567Set&lt;String&gt; s = new HashSet&lt;&gt;();...Iterator&lt;String&gt; seer = s.iterator();while (seer.hasNext()) &#123; String city = seer.next(); ...&#125; Iterator IterableCollection extends the Iterable interfaceEnhanced for loop works on object implementing iterable123public interface Iterable&lt;T&gt; &#123; Iterator&lt;T&gt; iterator();&#125; Iterator1234public interface Iterator&lt;T&gt; &#123;boolean hasNext(); T next();&#125; It will throw NoSuchElementException if user calls next() when hasNext() should return falseCan make a nested class implementing the Iterator Iterable vs. IteratorIterable =&gt; the object on which the iterator is performingIterator =&gt; defines methods which actually do the iteration Object MethodsAll classes extend from the Object class. toString() gives String representation of the object System.out.print() implicitly calls the method By default, Object class prints out the address of the object (hexadecimal String) String ‘+’ operator return a new String each time which take time linearly in the length of the whole String &emsp;&emsp;=&gt; use StringBuilder which is mutable equals(Object o) == operator== checks if two variables hold the same bitsif equal for primitive and if address equal for reference equals(Object o)By default, it is the same as == if not overridenChecks if null or other class (.getClass()) or the same address (i.e. the same object) Packages and Access Control Packages Package - namespace organizing classes and interfaceIssue: multiple classes with the same nameSolution: Appending class with a website address(backwards)&emsp;&emsp; e.g. ug.joshh.animal; // website is josh.ug Using Packages 1. Access within the same package &emsp;&emsp;Use the class name 2. Outside the package &emsp;&emsp;Use entire canonical name or import package and use simple name &emsp;&emsp;Wildcard import &emsp;&emsp;&emsp;&emsp;e.g. import ug.joshh.animal.* &emsp;&emsp;&emsp;&emsp;//danger: conflicts for multiple packages with same class Creating a Package 1. Put the package name at the top of each file 2. Store the file in the folder that has the appropriate folder name. &emsp;&emsp;e.g. ug.joshh.animal =&gt; ug/joshh/animal folder Create a Package in IntelliJ File -&gt; New Package -&gt; choose package name Add New Java Files to a Package in IntelliJ Right-click package name -&gt; New -&gt; Java Class Add Old Java Files to a Package in IntelliJ Add “package [name]” to the top of file -&gt; move .java file into folder Default Packages – class with no package name at the top JAR Files Zip all files by creating a JAR file (contain all .class file with additional info) JAR file is not safe =&gt; possible to unzip back into .java files Creating a JAR File in IntelliJ1. File -&gt; Project Structure -&gt; Artifacts -&gt; JAR -&gt; “From modules with dependencies”2. Ok multiple times3. Build -&gt; Build Artifacts (create a JAR file in a folder called “Artifacts”) Build Systems – Automate the setting up of project structure Maven, Ant, Gradle Access Control Package Private (black box) &emsp;&emsp;default access given to Java memebers without explicit modifier &emsp;&emsp;accessible between the same package (including default package) Public &emsp;&emsp;Signature should not change once deployed, if developers want to &emsp;&emsp;cancel public things, they call it deprecated Subtleties &emsp;&emsp;Access is based only on static type &emsp;&emsp;Default access mode for Interface is public not package private 123456789101112131415package universe;class HasHair implements BlackHole &#123; Object[] items; public void add(Object o) &#123; ... &#125; public Object get(int k) &#123; ... &#125;&#125;import static CreationUtils.hirsute;class Client &#123; void demoAccess() &#123; BlackHole b = hirsute(); HasHair hb = (HasHair) b; // HasHair is package private, this package does not see the existence of HasHair &#125;&#125; Reference:&emsp;berkeyley-cs61b]]></content>
      <categories>
        <category>CS61B</category>
        <category>Lecture Notes</category>
      </categories>
      <tags>
        <tag>Autoboxing</tag>
        <tag>Widening</tag>
        <tag>Immutability</tag>
        <tag>Generic Method</tag>
        <tag>Type Upper Bounds</tag>
        <tag>Exception</tag>
        <tag>Iteration</tag>
        <tag>Object Class</tag>
        <tag>Package</tag>
        <tag>Access Control</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS61B-3:Testing, Inheritance, Interface, Extends, Comparable, Comparator, ADTs, Abstract Class]]></title>
    <url>%2F2019%2F07%2F08%2FCS61B-3%2F</url>
    <content type="text"><![CDATA[Testing Junit TestingLibrary =&gt; org.junit Junit Methods1org.junit.Assert.assertArrayEquals(expected, input); https://junit.org/junit4/javadoc/4.12/org/junit/Assert.html Test Annotation@org.junit.TestEach test method can only be non-static12import org.junit.Testimport static org.junit.Assert.* Advantages 1. No manually test invoking 2. If one fails, the other still runs 3. Error msg much nicer to look Unit Testing vs. Integration Testing Test-Driven Development (TDD) Selection Sort Steps (Select Smallest + Swap)1. Find the smallest item2. Move it to the front3. Selection sort the remaining N – 1 items (without touching the front item)e.g. {6, 3, 7, 2, 8, 1} =&gt; {1, 3, 7, 2, 8, 6} =&gt; …… Inheritance, Interface Hypernyms, Hyponyms and Inheritance Hypernyms =&gt; superclass Hyponyms =&gt; subclass Interface =&gt; only provide what to do but not implementation (how to do) Interface Inheritance Subclass inherits all the methods/behaviors of the superclass Multi-generational (Alist -&gt; List -&gt; Collection) Implementation Inheritance default keyword specified in method signature in interface, method still overridable &emsp;e.g. default public void print() {…} Method Overloading vs Method Overriding Overloadingmultiple methods with the exact same name and different parameters 123e.g. default void flatter (Animal a); // Interface void flatter(Dog a); // subclass// It is an overloading not an overriding OverridingSubclass has a method with the same signature as in the superclass@Override tag =&gt; compiler error when making typos on signatureNo override for static method, only for instance method Dynamic Method Selection Static type =&gt; declared at compile time and never changes Dynamic type =&gt; equal to the type of object it is currently referring to at run time, specified at instantiation (new) Method Selection Algorithm 1foo.bar(x) // foo is of type TPrime and x is of type T1; compile time =&gt; the compiler verifies TPrime has a method that can handle T1 and records the signature of this method (if there are multiple methods, compiler will record the most specific one. e.g. bar(Dog) ☑️ vs. bar(Animal))runtime =&gt; if foo’s dynamic type overrides the recorded signature, then use the overridden method Puzzlethere 2 methods in the same class 123456public static void peek(List61B&lt;String&gt; list) &#123; System.out.println(list.getLast());&#125;public static void peek(SLList&lt;String&gt; list) &#123; System.out.println(list.getFirst());&#125; Run the following code 12345SLList&lt;String&gt; SP = new SLList&lt;String&gt;();List61B&lt;String&gt; LP = SP;SP.addLast("elk");peek(SP);peek(LP); The first call to peek() will use the second peek (cause it chooses the most specific one), the second call will use the first peek. Extends – hierarchical relationship between classes Extends Keyword MembersSubclasses inherit all members of the parent class (instance and static vars / methods / all nested classes), private members cannot be directly accessed by subclasses Constructorconstructors are not inheritedall constructor must start with a call to one of superclass’s constructorscan use this(…) to call a different constructor in the same class explicit call =&gt; super() or Java automatically make a call to superclass’s no-argument constructor if having one-argument constructor =&gt; use super(x)(implicit call not work) invoke superclass’s method by super.methodname() cannot use super.super.(…) Object ClassEach class is a descendant of the Object class (explicitly or implicitly extends), inheriting all members of Objects. But interface not extends object class Membershttps://docs.oracle.com/javase/8/docs/api/java/lang/Object.html.equal(Object obj).hashCode().toString() Encapsulation Basic ideaprograms should be built into modular, interchangeable pieceshiding information that others do not need Hierarchical abstractionAbstraction barriers – users not observe the internal working Design for change Inheritance breaks encapsulatione.g. Two methods A and B combined to achieve one functionality, but may by A calling B or B calling A to complete this. If one of them is overridden, sth wrong may happen Type Checking and CastingCompiler only allows method calls and assignments based on compile-time types ExpressionsExpressions using the new keywork also have compile-time typesMethod calls have compile-time types equal to their declared type CastingTell the compiler that a specific expression has a specific compile-time typeOnly matters with compile time and may cause runtime exceptions Higher Order Functions (HoF)HoF is a function that treats other functions as data (parameters)In Java7 and earlier, variables could not contain pointers to functions (no type for fcts)=&gt; take advantage of interface inheritance=&gt; an interface defining the function (defining a function type) and a class which implements this interface to represent a concrete function 123456789101112public interface IntUnaryFunction &#123; int apply(int x);&#125;public class TenX implements IntUnaryFunction &#123; /* Returns ten times the argument. */ public int apply(int x) &#123; return 10 * x; &#125;&#125;public static int do_twice(IntUnaryFunction f, int x) &#123; return f.apply(f.apply(x));&#125; Subtype Polymorphism Polymorphism Allows routines to use variables of different types TypesParametric Polymorphism (aka Generics)Subtype Polymorphism =&gt; due to inheritance An example of printing the larger of the two objectsExplicit HoF Approach=&gt; need a common way to achieve functionality 1234def print_larger(x, y, compare, stringify): if compare(x, y): return stringify(x) return stringify(y) &emsp;&emsp;Subtype Polymorphism Approach =&gt; object itself makes the choice =&gt; function &emsp;&emsp;is called dependent on what objects are 1234def print_larger(x, y):if x.largerThan(y): return x.str()return y.str() Comparable InterfaceCompare myself to another object =&gt; embedded within the object itselfDefines the natural ordering of type =&gt; only room for one compareTo method compareTo(T obj) return negative number if this &lt; o; return 0 if this equals to o; return positive number if this &gt; o; (return this.something – o.something) Comparator Interface A third party machine that compares two objects to each other Can define multiple ways to compare (e.g. size, name ….) compare(T o1, T o2)return negative number if o1 &lt; o2;return 0 if o1 equals to o2;return positive number if o1 &gt; o2; 123456789101112131415161718import java.util.Comparator;public class Dog implements Comparable&lt;Dog&gt; &#123;... public int compareTo(Dog uddaDog) &#123; return this.size - uddaDog.size; &#125; private static class NameComparator implements Comparator&lt;Dog&gt; &#123; public int compare(Dog a, Dog b) &#123; return a.name.compareTo(b.name); &#125; &#125; public static Comparator&lt;Dog&gt; getNameComparator() &#123; return new NameComparator(); &#125;&#125; Java Libraries and packages Abstract Data Types (#ADTs)Defined only by its operations but not by its implementationIn Java, aka interface java.util libraryList: an ordered collection of itemsSet: an unordered collection of strictly unique itemsMap: a collection of key/value pairs Java Features Take less time to write programStatic Types (type checking and help guide programmers)Bias to interface inheritance =&gt; cleaner subtype polymorphismAccess control modifiers =&gt; abstraction barriers more solid More efficient codeMore control over engineering tradeoffsSingle valued arrays =&gt; better performance Basic structure =&gt; more closely resemble underlying hardware Interface vs. Abstract Class InterfaceAll methods must be public (redundant)All variables must be public static final&emsp;Can never be changed&emsp;No instance variablesCannot be instantiatedAll methods are by default abstract unless specified to be defaultCan implement more than one interface per class Abstract Class (lie between interfaces and concrete classes)Method can be public or privateCan have any types of variablesCannot be instantiatedMethods are by default concrete unless specified to be abstractCan only implement one per class Reference:&emsp;berkeyley-cs61b]]></content>
      <categories>
        <category>CS61B</category>
        <category>Lecture Notes</category>
      </categories>
      <tags>
        <tag>Testing</tag>
        <tag>Inheritance</tag>
        <tag>Interface</tag>
        <tag>Extends</tag>
        <tag>Comparable, Comparator</tag>
        <tag>ADTs</tag>
        <tag>Abstract Class</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dynamic Programming]]></title>
    <url>%2F2019%2F07%2F08%2FDynamic-Programming%2F</url>
    <content type="text"><![CDATA[Those who cannot remember the past are condemned to repeat it. Starting From Fibonacci NumberFibonacci Number is a series of number satisfying $F(n) = F(n - 1) + F(n - 2)$, for examaple, {0, 1, 1, 2, 3, 5, 8, 13…}. Intuitively, we may resort to recursive approach to this problem. Thought it is pretty straightforward, the ineffiecient recursive call takes the cost of your computational time. So, why is that ? Let’s think about the structure of the call tree. Each fibonacci number relies on the computing of the other two fibonacci number ahead of it. The image before shows the call tree when you get the input as 6 and it is not hard to realize that the tree will have $2^n$ nodes in total with the depth n. The essence of the inefficiency of this approach lies in that we can compute the same fibonacci number (e.g. fib(3) for 3 times) for multiple times which is totally unnecessary. So here is where the Memoization comes in to resue. Top-Down MemoizationAs we have seen the above case, the issue is that the subproblems of the whole problem overlap in some parts leading to ineffecient and unnecessary recalculation. Then how to fix it ? Well, it is quite simple, we trade space with time by keeping a table to record the work you’ve done and you can just return the answer if the subproblem has already been done once. That is roughly the basic idea of Memoization. In general, top-down Memoization is that you start solving the whole problem by breaking it into pieces. Return the solution recorded if the subproblem has already been solved once or solve the subproblem for once otherwise. Ok, now let’s take a deeper look by comparing the memoization approach and non-memoization approach in the context of the fibonacci problem. First, the time complexity. For the non-memoization approach, the time complexity is $O(2^n)$ while for the memoization approach is $O(n)$ which is much better. Then for the space complexity. Remember, space complexity takes any memory you use into account including the call stack. Thus, the space complexity of non-memoization approach is $O(n)$ (e.g. fib(6) - fib(5) - fib(4) - fib(3) - fib(2) - fib(1), the fib(6) has not called fib(4) yet) and it is the same for the memoization approach too (memory for record table). Down-Top TabulationDifferent from Memoization, tabulation solves the problem by starting from the most trivial subproblem, upwards to the top. Let’s look at an example to see how this works. Calculate the total number of possible path to the destination in the image Divide the Problem RecursivelyTo analyze this problem, the green guy can simply walk downwards or to the right (you know, it will be stupid to turn back (i.e. to the left and upwards)). Thus, we can divide this problem as separate steps along path as below.&emsp;&emsp;&emsp;$Path(start, end) = Path(A, end) + Path(B, end) = …$ Memoization vs. RecursionWe can see from the image above that Path(C, end) will be calculated twice and so are others, which is fairly inefficient. That is because there are overlapping between some subproblems. Thus we can take the Memoization approach to make sure each subproblem solved only once. To do this, we can use a table to record the total number of paths from a specific point to the end. Start by the Most Trivial ProblemDynamic Programming solves problem from down to top. This idea applies here as well. Instead of starting from the start point, we can think of this problem from the end point backwards.&emsp;&emsp;&emsp;$Path(P, end) = Path(P’s\ right, end) + Path(P’s\ down, end)$Thus, we can compute the whole table from the right to left and then down to up. SummaryIn a nutshell, dynamic programming is suitable for the situation where you can divide problem into sub-problems which can be broken down to smaller sub-problems and there is overlapping in solving the sub-problems. It is efficient by only computing the overlapping part once. Basically, optimization and combinatorial problems are of the two most typical problem of dynamic programming problems. The optimization problem requires you to find a feasible solution so that the objective function can be optimized while the combinatorial problems want you to compute the number of ways to do something or possibility of some event happening. Do note that similar to divide-and-conquer though it is, dynamic programming is better when there is overlapping between the subproblems while the divide-and-conquer doesn’t. Problem Number in LeetCode#53 (Maximum Subarray)#62 #63 #64 (Path Stuff)#70 (Climbing Stairs)#123 (Best time to buy and sell III)#174 (Dungeon Game) For boundary, can assign dp[m+1][n+1] instead of dp[m][n]#198 #213 (House Robber) dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])#264 (Ugly Number) (nth ugly numbe = min(2*ugly[i2], 3*ugly[i3], 5*ugly[i5]))#300 (Longest Increasing Subsequence) DP with binary search#303 (Range Sum Query) #304 (Range Sum Query - 2D)#322 (Coin Change)#329**(Longest Increasing Path In a Matrix) DFS or BFS#338 (Counting Bits)#343 (Integer Break)#357 (Count Numbers with Unique Digits)#413 (Arithmetic Slices)#416 (Partition Equal Subset Sum) =&gt; dp[i] whether sum i can be achieved = dp[i] || dp[i - num]#552 (Student Attendance Record II)#746 (Min Cost Climbing Stairs) Reference:&emsp;youtube - Algorithms: Memoization and Dynamic Programming&emsp;An intro to Algorithms: Dynamic Programming&emsp;Tutorial For Dynamic Programming]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS61B-2: Bits, Type, Lists, Sets]]></title>
    <url>%2F2019%2F07%2F06%2FCS61B-2-Bits-Type-Lists%2F</url>
    <content type="text"><![CDATA[Arrays have a fixed size ?Then come Lists ! BitsMemory is stored as a sequence of 0 and 1 and bits Interpreted using types Variable Types 8 primitive types: byte, short, int, long, float, double, char, boolean Reference Types Golden Rule of Equals x = y =&gt; copy the bits from y to x Parameter Passing =&gt; just copy the bits (pass by value always) Object Instantiation Declaring a Variable (primitive type)1. Set aside memory (Java will set aside exact bits to hold a thing of type)2. Create an entry in an internal table that maps variable name to the location of the first bit in the box by Java Interpreter☑️ Java does not write anything to reserved boxes when declaring variables (no default values)☑️ Java does not allow accessing a variable uninitialized Reference Variables declaration1. Allocate a box of 64 bits2. Address of instance returned by new operator and bits copied into boxNull == all zeros Using new keyword1. Allocates a box for each instance variable of the class and fills them with a default value.2. Constructor then usually fills every box with some other value(In real Java, there is additional overhead for any object) Arrays Instantiation Arrays Structure A fixed integer length N A sequence of N memory boxes where all boxes are of the same type (0 thru N - 1) Array Creation 123x = new int[3]; // each box filled a default value (e.g. 0) y = new int[]&#123;1, 2, 3, 4, 5&#125;; // specified starting valuesint[] z = &#123;9, 10 ,11, 12, 13&#125;; // declare and create z, omit new keyword (only used with declaration) Copy Array123//faster than copying item by item using loopSystem.arraycopy(srcArray, startPosInSrc, targetArray, startPosInTarget, lenToCopy)e.g System.arraycopy(b, 0, x, 3, 2); // b &#123;9, 10, 11&#125;, x &#123;1, 2, 3, 4, 5&#125; -&gt; &#123;1, 2, 3, 9, 10&#125; Java Arrays only perform bounds checking at runtime 2D Arrays – Array of Array References1234int[][] bamboozle = new int[4][]; // create an array of int arrays (4 memory boxes, each points to an array of int(unspecifid length)), only 1 array createdint[][] bamboozle = new int[4][4]; // create 5 arraysint[] rowZero = bamboozle[0];int[][] x = &#123; &#123;1, 2, 3&#125;, &#123;4, 5, 6&#125;, &#123;7, 8&#125; &#125;; Basic Int Linked List&emsp;Naked recursive data structure 1234567891011121314151617public class IntList &#123; public int first; public IntList rest; public IntList(int f, IntList r) &#123; first = f; rest = r; &#125; /** Return the size of the list using... recursion! */ public int size() &#123; if (rest == null) &#123; return 1; &#125; return 1 + this.rest.size(); &#125;&#125; Singly Linked List (SLList) Improvement #1: Rebranding &emsp;Rename IntList class to IntNode class Improvement #2: Bureaucracy &emsp;IntNode is hard to work with =&gt; create a separate class called SLList &emsp;SLList as a middle man between user &amp; naked recursive data structure Improvement #3: Public vs. Private &emsp;Declare first variable of SLList class as private &emsp;&emsp;=&gt; inaccessible naked data structure Improvement #4: Nested Classes &emsp;Embed a class declaration inside of another Static Nested classesWhen nested class never use any instance members of the outer class =&gt; can not access any of the members of the enclosing classSave small amount of memory Improvement #5: addLast(), size() and Caching Recursive Approach of size() Slow method for long list (scan thru the whole list) 1234567891011/** Returns the size of the list starting at IntNode p. */private static int size(IntNode p) &#123; if (p.next == null) &#123; return 1; &#125; return 1 + size(p.next);&#125;public int size() &#123; return size(first);&#125; OverLoaded Method Two methods with the same name but different signatures Caching Add a size variable to track the current size Increase memory usage and slow down add method Improvement #6: The Empty List&emsp;Constructor to create an empty list (first = null; size = 0)&emsp;&emsp;=&gt; addLast Null Pointer Excep&emsp;SLList with Sentinel Node Doubly Linked List (DLList) Limitations of SLList and FixLimitation and Reason =&gt; Slow method for long list (scan thru the whole list)Approach #1: add a last variable&emsp;Limitations: addLast () and getLast () will be fast but removeLast () will be&emsp;slow (to get second-to-last node) &emsp;&emsp; Approach #2: Looking Back – Doubly Linked List&emsp;&emsp; Add a previous pointer to each node, 2 links for each node &emsp;&emsp; Limitation: last pointer sometimes points at the sentinel node and sometimes a&emsp;&emsp; real node =&gt; getLast() method wrong Improvements: Sentinel UpgradeApproach #1: add a second sentinel node &emsp;&emsp; Approach #2: Circular List&emsp;&emsp; front and back pointer sharing the same sentinel node Generic Lists (e.g. DLLists) Limitations of the Above ListsThey can only hold integer values Generics Declaration Syntax123public class DLList&lt;T&gt; &#123; public T item;&#125; Instantiation Syntax 1DLList&lt;String&gt; d2 = new DLList&lt;&gt;(“hello”); Syntax Details ☑️Generics only work with reference type; ☑️Empty diamond operator can be used during instantiation if declaration happens at the same line (but can also declare the type inside of the angle brackets during instantiating) ArrayList Linked List Performance of get(i)Linear in the size of the entire listSlow for random access =&gt; use array instead Array ResizingApproach #1: add more size at once =&gt; slowApproach #2: multiply size by 2 (scaling factor) – Geometric Resizing Improvement: Spike of eventsUsage ratio = size of the list / length of the arrayHalf the size when ratio &lt; 0.25 Generic AList12Glorp[] items = new Glorp[8]; // Wrong! Generic Type cannot be instantiated directly !Glorp[] items = (Glorp[]) new Object[8]; // Right ! only a compilation warning Nulling out deleted items for generics objects to avoid loitering (Java only destroys (garbage collects) object when the last reference has been lost) List and Set in Real World ListInterface: java.util.ListImplementations: java.util.ArrayList, java.util.LinkedList SetSets – a collection of unique elements, no sense of orderInterface: java.util.SetImplementations: java.util.HashSet, java.util.TreeSet Reference:&emsp;berkeyley-cs61b]]></content>
      <categories>
        <category>CS61B</category>
        <category>Lecture Notes</category>
      </categories>
      <tags>
        <tag>Bits</tag>
        <tag>Type</tag>
        <tag>LinkedList</tag>
        <tag>ArrayList</tag>
        <tag>Set</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Knuth-Morris-Pratt(KMP) Algorithm]]></title>
    <url>%2F2019%2F07%2F06%2FKnuth-Morris-Pratt-KMP-Algorithm%2F</url>
    <content type="text"></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Big Data Analytics]]></title>
    <url>%2F2019%2F07%2F06%2FBig-Data-Analytics%2F</url>
    <content type="text"></content>
      <categories>
        <category>CC</category>
        <category>Big Data Analytics</category>
      </categories>
      <tags>
        <tag>sequential analytics</tag>
        <tag>MapReduce</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git: Local & Remote Repo]]></title>
    <url>%2F2019%2F07%2F06%2FGit-Local-Remote-Repo%2F</url>
    <content type="text"><![CDATA[Git &amp; Local Repos Version Control System&emsp;Track the history of code revision&emsp;Git is a distributed version control system&emsp;&emsp;&emsp;each developer’s computer store the entire history&emsp;Repository = entire history of an entire project Git Config12$ git config –global user.email “you@xxx.edu”$ git config -global user.name “your name” Local Repositories12345678$ cd to directory$ git init # tell the version control system that we want to track history of directory but nothing is stored in the repository at this point$ git add ./blahblah # store things in the repository, but still nothing stored yet, just add files to the list of files to track (you may not want to track all files in directories)$ git status # changes to be committed (list files trakced and whose changes ready to be committed) / untracked files$ git commit -m “add some stuffs” # stick copies of files into the repository / -m add message to the commit$ git log # see evidence of snapshot (commit ID)$ git show commitID # peek inside of the commit$ git checkout commitID filepath # roll back files but does not change the commit history / checkout auto does a git add on roll back files Local Repositories (Technical Overview) Initializing Local Repositories&emsp;Repositories: store files as well as history of changes to files&emsp;Initialize git repositories -&gt; create a .git subdirectory (store metadata as&emsp;well as old the actual snapshots of the files) Tracked vs Untracked Files&emsp;Tracked Files: been added to git repository&emsp;Untracked Files: never been tracked or removed from tracking (git not keep history) Staging &amp; Committing&emsp;commit =&gt; specific snapshot of working directory (users specify what composes the snapshot by staging file) Undoing Changes&emsp;Unstage a file1$ git reset HEAD [file] # unstage a file that you have not yet committed (leave changes intact) &emsp;Amend latest commit (change message or add forgotten files)12$ git add [forgotten-files]$ git commit –amend # This commit will replace previous commit &emsp;Revert a file to its state at the time of the most recent commit1$ git checkout -- [file] Git &amp; Remote Repo Remote Repositories&emsp;Store copies of your repositories on computers other than yours&emsp;By convention the name of the primary remote is called origin Remote Add12345$ git remote add [remote-repo-name] [remote-repo-URL] # record a new location for network data transfere.g. $ git remote add origin https://github.com/.......$ git remote rename [old-name] [new-name] # rename the repo$ git remote rm [remote-name] # remove the repo$ git remote -v # list all locations for network data transfer Cloning a Remote1$ git clone [remote-repo-URL] # make a copy of repository and record the URL of the remote repo for network data transfer and name it as origin Pushing Commits12$ git push [remote-name] [remote-branch] # push commits to GitHube.g. $ git push origin master Fetching &amp; Pulling Commits12$ git fetch [remote-name] # only update your local copy of the remote code but not merge the changes into your own code $ git pull [remote-repo-name] [remote-branch-name] # get the most recent copy of the files as seen in remote-repo-name (== fetch + merge, also merge the changes into your HEAD branch) Git Branching Intro&emsp;Branches =&gt; allow keeping track of multiple different versions of work&emsp;Git data structure is a graph (branch pointers and commits as nodes) Creating, Deleting &amp; Switching Branches&emsp;HEAD pointers references the branch you currently have and Branching&emsp;instructions modify branches and change what HEAD points to 12345$ git branch [new-branch-name] # create a branch off of your current branch$ git checkout [destination-branch] # switch branches$ git checkout -b [new-branch-name] # create a new branch and switch to it$ git branch -d [branch-to-delete] # delete a branch$ git branch -v # figure out which branch you are on Merging (Merge one branch into another) command12$ git checkout master $ git merge [other-branch-name]. # merge the other branch into master &emsp;this will create a new commit that joins two branches and change each pointer to this new commit / first parent–commit on the master branch / second parent–other branch Merge Conflicts and Resolving If commits on the two branches changed the same files (Sometimes conflict can not be resolve =&gt; will present both changes from the different branches) Git tells which files have conflict =&gt; open files =&gt; resolve manually =&gt; commit 2 segments of code&emsp;Top code snippet =&gt; branch originally had checked out when running merge command =&gt; called HEAD&emsp;Bottom code snippet =&gt; branch you were merging into your checked out branch Reference:&emsp;berkeyley-cs61b-lab1&emsp;git documentation]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS61B-1:Java Intro, Classes]]></title>
    <url>%2F2019%2F07%2F05%2FCS61B-1-Java-Intro-Classes%2F</url>
    <content type="text"><![CDATA[Running a Java Program .java-&gt; javac (compiler) -&gt; .class (Java bytecode) -&gt; java (Interpreter) -&gt; runs .class file 1. safer (type checked) 2. faster (for machine to execute) 3. protect intellectual property Static Typing Statically Typed language&emsp;All Variables have a declared type and type can never be changed&emsp;Expressions have a type&emsp;Compiler will check and make sure the type right before the program runs Pros and Cons Pros catch certain types of errors type errors never occur on end users easier to read and reason about the code run efficiently (no runtime type checking) Cons code is more verbose code is less general but it can be solved by generics Static vs. Non-Static Instance Variables and Object Instantiation&emsp;Problem: Not all objects of a class are equal&emsp;&emsp;=&gt; Approach1: create separate classes for each =&gt; redundancy&emsp;&emsp;=&gt; Approach2: classes instantiated and instances hold data&emsp;&emsp;&emsp;&emsp;e.g. Type ins = new Type();&emsp;Instance Members (Variables/Methods) = Non-Static Members (Variables/Methods) Constructors&emsp;Parameterized instantiation Class (Static) Methods VS Instance (Non-Static) Methods Static Methods&emsp;invoked using the class name Static Variables&emsp;properties inherent to class itself&emsp;accessed using name of class Instance Methods&emsp;actions that can be taken only by a specific instance of a class&emsp;Keyword this to refer to the current object Arrays of Object 2 steps of initializing arrays&emsp;=&gt; First use new keyword to create the array (Dog[] dogs = new Dog[2])&emsp;=&gt; then use new again for each object that you want to put into the array The array index starts at 0 in Java Array.length Alternate way of defining array&emsp;int[] numbers = new int[] {4, 7, 10}; Summary of Terminology Instance Variables (Properties) Non-static Methods (Instance Methods) Constructors (How to instantiate the class)Declaration + Instantiation + Assignment + Invocation of Methods Reference:&emsp;berkeyley-cs61b]]></content>
      <categories>
        <category>CS61B</category>
        <category>Lecture Notes</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Git</tag>
        <tag>Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F04%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Others</category>
      </categories>
  </entry>
</search>
