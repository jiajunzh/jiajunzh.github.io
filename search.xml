<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Road Test Runbook]]></title>
    <url>%2F2021%2F10%2F12%2FDriving-Runbook%2F</url>
    <content type="text"><![CDATA[Road Test Overview Pre-driving Check Critical Errors/Mandatory Failures Vehicle Movement Parallel Parking Hill Operation Backing 50 Feet Three Point Turn Turning Lane Change/General Driving Pre-driving CheckNot Relevant Critical Errors/Mandatory Failures Seat belt Hand signal Yeld to emergency vehicle / pedestrain / school bus / taffic safety personnel Traffic sign Traffic light Traffic markings violation Not Block crosswalk Speed 15-25 mph Vehicle MovementAcceptance Criteria Gear selection Signal Check traffic Check blind spot Smoothly transition into traffic Stop vehicle Come to a full stop Park-E brake on/off Fail to follow instructions Parallel ParkingAcceptance Criteria Signal Check traffic Check blind spot Look over shoulder Use less or equals to two corrections to position vehicle Successful maneuver Runbook (2 + 4 + 2 + 3 + 4)Part 1: Signal and Line Up Signal Right Line up (keep 2-3 feet distance) Part 2: Backing Up to 45 degrees Look blind spot (check pedestrain and traffic) R gear Steering wheel to the right (1 circle) Back up ====&gt; Stop Condition: 45 degrees (When your front passes the parked vehicle’s read bumper) Part 3: Straighten the Wheel and Backing Up Steering wheel straightened Back Up ====&gt; Stop Condition: front door holder hits the road curb Part 4: Turn Left and Backing Up Steering wheel to the left (1 circle) Back up Straighten your wheels and pull forward Part 5: Start Hitting Road Signal Left D gear Look blind spot (check pedestrain and traffic) Drive Note Look out rear window when backing up! Do not always look at the mirror! Keep enough space in front of and behind you Hill OperationAcceptance Criteria Signal Check traffic Check blind spot Applies park-E brake Position wheels Successful maneuver Runbook Backing 50 FeetAcceptance Criteria Signal Check traffic Check blind spot Look over right shoulder Back up in a safe/smooth speed Maintain lane Successful maneuver Three Point TurnAcceptance Criteria Signal Check traffic Check blind spot Yield to oncoming traffic Look over shoulder Correct number of turns 3 Successful maneuver Runbook (2 + 4 + 4 + 5)Part 1: Pull Over (Optional) Signal right Pull over to the right edge of the road Part 1: First Turn Signal left Check for traffic and pedestrains Steering wheel to the left (full) Turn left ====&gt; Stop Condition: vehicle perpendicular to road curb Part 2: Second Turn Steering wheel to the right (full) Check for traffic and pedestrains R gear Back up ====&gt; Stop Condition: vehicle perpendicular to road curb Part 3: Third Turn Check for traffic and pedestrains Signal left D gear Steering wheel to the left Drive and finish the turn Note Signal !! Check for traffic and pedestrains !! TurningAcceptance Criteria Signal Check traffic Check blind spot Use correct lane for turn Blocks travel lane Improper speed 15 - 25 MPH Turn is too wide/too short Lane Change/General DrivingAcceptance Criteria Signal Check traffic Check blind spot Improper hand positions Improper steering techniques Improper merge/yield Unecessary stops Intersection non-compliance Resources https://www.youtube.com/watch?v=ygu-7qZ39gs]]></content>
      <categories>
        <category>Driving License</category>
      </categories>
      <tags>
        <tag>Road Test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git Overview]]></title>
    <url>%2F2021%2F10%2F11%2FGit-Overview%2F</url>
    <content type="text"><![CDATA[Version Control System Introduction Version Control System Tools to keep track of changes to files over time Allow you to view/revert back to previous iterations of files Git Distributed version control system: each developer’s laptop stores the entire history of a project (repository - files + history) Allow usage without Internet Local RepositoryInitializing Local Repository1$ git init # Initialize the repository, stay in the directory of which the history you want to track Note: upon initialization, Git creates .git sub-directory which stores metadata and snapshots of files. Tracked vs Untracked Files Untracked Files: files that either never been tracked or were removed from tracking. Git not maintaining history for these files. Tracked Files: files have been added to the Git repository and can be in various stages of modification: unmodified/modified/staged. Unmodified: files that has had no new changes since the last version of the files was added to the Git repo Modified: different from the last one Git has saved Staged: user has designated as part of a future commit (usually thru use of the git add command) Staging &amp; Committing12$ git add FILE # Stage files$ git commit -m MESSAGE # Commit (snapshot of your working directory at a particular time) Undoing Changes123456789# Unstage a file that you haven&apos;t yet committed. Change file status back to modified without touching changes$ git reset HEAD [FILE] # Amend the latest commit $ git add [forgetten-file]$ git commit --amend# Revert a file to its state at the time of the most recent commit $ git checkout -- [file] Remote Repository12345678910111213141516# 1. Makes a copy of the specified repository on your local computer.# 2. Create a working directory that has files arranged the same as the most recent snapshot# 3. Record URL of the remote repo for subsequent network data transfer and give it the remote-repo-name &quot;origin&quot;$ git clone [remote-repo-URL] # Record a new location for network data transfers $ git remote add [remote-repo-name] [remote-repo-URL]# List all locations for network data transfers $ git remote -v# Get the most recent copy of the files as seen in remo-repo-name $ git pull [remote-repo-name] master # Push the most recent copy of your files to the remote-repo-name$ git push [remote-repo-name] master Git Branching (Advanced Git)TODO Other Git FeaturesTODO Remote Repositories (Advanced)Git Commands git initInitialize the directory of which the history will be tracked by the git version control system. git addAdd the file to tracking list (but not save the file yet because you might not want to track every file in the directory). git status git commit -mStore a snapshot of all added files into the repository git log git show Peek into the commit git checkout Resources Git Official Documentation]]></content>
      <categories>
        <category>CS61B</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>CS61B</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cat Insurance Research]]></title>
    <url>%2F2021%2F10%2F10%2FCat-Insurance%2F</url>
    <content type="text"><![CDATA[Below is a demo of Demo! 🐈 General OveviewGenerally, things need to be covered include both wellness plan and insurance. Wellness plan ususally is provided by pet hospitals such as VCA and Banfield or sometimes could be supported by insurance company, covering exams, flea treatment, vaccinations, spray and etc. Insurance normally only covers accidents and illness with its deductible and reimbursement. Insurance OptionsFIGOWebsite Linkhttps://quote.figopetinsurance.com/ Price 1234Insurance: $31.11/month ($373.32/year) - 90% coverage + $250 deductible + unlimited annual benefitWellness Plan Basic: $9.50/month - $135 annual coverage Wellness Plan Plus: $16.50/month - $250 annual coverageExtra Care Pack: $6.62/month (Not recommended) Pros and Cons👆Unlimit annual payouts option for insurance👆4 days claim repayment on average👆Prescription Medications👆Great customer rating👆Waiting period: 14 days 👇Wellness plan does not save much compared to annual payouts👇Exam fee for an extra fee/prescription food Healthy PawsWebsite Linkhttps://www.healthypawspetinsurance.com/ Price 1$22.22/month ($266.64/year) - 90% coverage + $250 deductible + unlimited Pros and Cons👆No maximum annual or lifetime payouts👆Fast claim processing. Mostly within 2 days👆Prescription Medications👆Great customer rating👆Waiting period: 15 days 👇Not included: pre-existing conditions, preventative/routine care, spay/neuter procedures and office visist fee or examination fee PetsbestWebsite Linkhttps://www.petsbest.com/ Price 1Plus: $23.93/month ($287.16/year) - 90% coverage + $250 deductible + unlimited Pros and Cons👆Unlimited👆Reasonable price👆Waiting period: 14 days👆Accident &amp; Ilness Exam Fees Included 👇Long processing time for reclaim up to one month （25-40 days） LemonadeWebsite Linkhttps://www.lemonade.com/pet Pros and Cons👇 Not launched in Boston : ( PumpkinWebsite Linkhttps://www.pumpkin.care/ Price 12Insurance: $44.62/month ($535.44/year) - 90% coverage + $250 deductible + $15k annual limit Preventive Pack: $11.95/month - Fecal Test + Annual Wellness Exam Fee + Vaccine for Disease Preventation Pros and Cons👆Sick visist exam fees and prescription food for eligible conditions are covered.👆Pre-Existing condition only lasts for 180 days. 👇Annual limit.👇Expensive. NationwideWebsite Linkhttps://www.petinsurance.com/ Price 1$37.59/month ($451.08/year) - major medical + pet wellness Pros and Cons👆Three types of insurance: whole pet, major medical and pet wellness 👇Expensive👇Long processing time👇Major medical plan has annual payout limits per condition ASPCAWebsite Linkwww.aspcapetinsurance.com Price 1$40.08/month ($480.96/year) - 90% coverage + $250 deductible + $10,000 upper limit Pros and Cons👆Pre-Existing condition only lasts for 180 days.👆Waiting period 14 days👆Include exam fees👆Prescription medication 👇Long processing time👇 Upper limit PetPlanWebsite Linkhttps://www.gopetplan.com/ Price 1$51.67/month ($620.04/year) - 90% coverage + $250 deductible + No upper limit Pros and Cons👆Exam fee included👆Pre-Existing condition only lasts for 365 days.👆Waiting period 15 days👆Unlimited maximum payouts👆Prescription medication 👇 Expensive EmbraceWebsite Linkhttps://www.embracepetinsurance.com/ Price 1$34.07/month ($408.84/year) - 90% coverage + $250 deductible + $30,000 Pros and Cons👆Great customer review👆Waiting period 14 days👆Claim 8 - 9 days👆Exam fees included👆Optional wellness plan👆Prescription medication 👇Expensive👇Upper limit Flea TreatmentFlea treatment - https://www.pets-megastore.com.au/ revolution plus $8/pack Essential Cat VaccinationsFVRCP + Rabies https://www.dealmoon.com/guide/931190 Resources https://www.1point3acres.com/bbs/thread-678031-1-1.html https://instant.1point3acres.com/thread/679105 https://www.dealmoon.com/guide/891340 https://www.dealmoon.com/guide/764201 https://www.caninejournal.com/pet-insurance-reviews/]]></content>
      <categories>
        <category>CatDemo</category>
      </categories>
      <tags>
        <tag>CatDemo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-Dynamic Programming]]></title>
    <url>%2F2019%2F07%2F16%2FLeetCode-Dynamic-Programming%2F</url>
    <content type="text"><![CDATA[#123 Best Time to Buy and Sell Stock IIIInput is an array for which the ith element is the price of a given stock on day i.Find the maximum profit. You may complete at most two transactions.Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again). Example 1:Input: [3,3,5,0,0,3,1,4]Output: 6Explanation: Buy on day 4 (price = 0), sell on day 6 (price = 3), profit = 3-0 = 3.Then buy on day 7 (price = 1), sell on day 8 (price = 4), profit = 4-1 = 3. This is a hard-level problem on the LeetCode, which takes me much time to think about. Thus, I’d like to write this post to review this problem. Basically, we can imagine this as two separate purchase-selling process, i.e. [first buy …. first sell] [second buy …. second sell]. It is worth noting that second buy happens only after the first sell. In this way, we can turn this two processes into one-time purchase-selling process which the price on i-th day takes the maximum profits before day i into account.&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;$newPrices[i] = prices[i] - maximum\ Profit\ of\ first\ buy$Using dynamic programming algorithm, the implementation is shown as below. 12345678910111213141516171819202122232425class Solution &#123; public int maxProfit(int[] prices) &#123; if (prices == null || prices.length &lt;= 1) &#123; return 0; &#125; int maxProfit = 0; int minCost = prices[0]; int[] dp = new int[prices.length]; dp[0] = prices[0]; // compute the newPrice and store the record in dp[] for (int i = 1; i &lt; prices.length; i++) &#123; minCost = Math.min(minCost, prices[i]); maxProfit = Math.max(maxProfit, prices[i] - minCost); dp[i] = prices[i] - maxProfit; &#125; maxProfit = 0; minCost = prices[0]; // find the max profit as you only buy once for (int i = 0; i &lt; prices.length; i++) &#123; minCost = Math.min(minCost, dp[i]); maxProfit = Math.max(maxProfit, prices[i] - minCost); &#125; return maxProfit; &#125;&#125; The above implementation takes two pass. However, if we look a little deeper, we can find that the two pass can actually be combined as one like below. 123456789101112131415class Solution &#123; public int maxProfit(int[] prices) &#123; int sell1 = 0; // maximum profit after first sell int sell2 = 0; // total maximum profit after second sell int buy1 = Integer.MAX_VALUE; int buy2 = Integer.MAX_VALUE; for (int i = 0; i &lt; prices.length; i++) &#123; buy1 = Math.min(buy1, prices[i]); sell1 = Math.max(sell1, prices[i] - buy1); buy2 = Math.min(buy2, prices[i] - sell1); sell2 = Math.max(sell2, prices[i] - buy2); &#125; return sell2; &#125;&#125; Well, I think the above approach is the most compact way to solve this while I think there are other perspectives to look at this problem. For instance, using DP, you can build two arrays, one to store the maximum profit of one buy-sell before day i and one for after day i. We just find the Max(Sum(two arrays)) to solve this problem. #213 - House RobberIIYou are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. ExampleInput: [2,3,2]Output: 3Explanation: You cannot rob house 1 (money = 2), then rob house 3 (money = 2),because they are adjacent houses. That it the #213 problem in the LeetCode. However, to solve this problem, let’s first review the easy-version of this problem, #198 in the LeetCode in which all the houses are arranged as a line but not a circle. These two are typical dynamic programming problems. For #198, imgaine that we have robbed i - 1 houses and come in the front of the i-th house. Now we need to decide if we should rob this one. But How ? It turns out that whether we rob the house i depends on two values, the total profit of robbing house i and the totoal profit of not robbing house i before coming to house i + 1. $Total\ Profit\ Of\ Robbing\ i = Total\ Profit\ Of\ Robbing\ (i-2) + Profit\ Of\ Robbing\ i$$Total\ Profit\ Of\ Not\ Robbing\ i = Total\ Profit\ Of\ Robbing\ (i-1)$ We choose the larger one and come to the next house. The code is shown as below. 12345678910111213141516171819class Solution &#123; public int rob(int[] nums) &#123; if (nums == null || nums.length == 0) &#123; return 0; &#125; if (nums.length == 1) &#123; return nums[0]; &#125; int lastHouse = nums[0] &gt; nums[1] ? nums[0] : nums[1]; int lastTwo = nums[0]; int maxProfit = lastHouse; for (int i = 2; i &lt; nums.length; i++) &#123; maxProfit = Math.max(lastTwo + nums[i], lastHouse); lastTwo = lastHouse; lastHouse = maxProfit; &#125; return maxProfit; &#125;&#125; Well, now let’s get back to the #213. The only difference here is that houses are arranged in a circle right now. The key here is that the start house and end house cannot be robbed at the same night. So, either you don’t rob start house or you don’t rob end house. Assume that for some strange reasons, you don’t want to rob the start house, then you are allowed to rob the last one. Actually this case is just like the situation where the start house does not appear in the array. Similarly, if you choose not to rob the last one, the case is just like that the last house does not appear in the array. Thus, the answer is just the maximum money of the two cases. The implementation is shown as below. 12345678910111213141516171819202122232425262728class Solution &#123; public int robHelper(int[] nums, int start, int end) &#123; if (start &gt; end) &#123; return Integer.MIN_VALUE; &#125; if (start == end) &#123; return nums[start]; &#125; int lastHouse = nums[start] &gt; nums[start + 1] ? nums[start] : nums[start + 1]; int lastTwo = nums[start]; int maxProfit = lastHouse; for (int i = start + 2; i &lt;= end; i++) &#123; maxProfit = Math.max(lastTwo + nums[i], lastHouse); lastTwo = lastHouse; lastHouse = maxProfit; &#125; return maxProfit; &#125; public int rob(int[] nums) &#123; if (nums == null || nums.length == 0) &#123; return 0; &#125; if (nums.length == 1) &#123; return nums[0]; &#125; return Math.max(robHelper(nums, 0, nums.length - 2), robHelper(nums, 1, nums.length - 1)); &#125;&#125; #221 Maximal SquareGiven a 2D binary matrix filled with 0’s and 1’s, find the largest square containing only 1’s and return its area. Example: Input:$1\ 0\ 1\ 0\ 0$$1\ 0\ 1\ 1\ 1$$1\ 1\ 1\ 1\ 1$$1\ 0\ 0\ 1\ 0$ Output: 4 Yet another DP problem today. This problem expects us, in short, to find the maximal square with all 1’s in the matrix. Suppose now we are up to the element matrix[i][j] and the element is 1. Now we get 2 paths. One is that the new element can combine its adjacent elements to make a bigger square or they can not. So how could we decide which one of the above path to take? Now we just pretend that we could take the former one, and the newly generated square is m x m large. Ok, now we know that up till the element matrix[i][j], we can get a square whose side length is m. If we record the maximal side length of square with the element[i][j] as the bottom right points for each element as dp[i][j], then we know, dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1. Actually, the three values dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1] limits the three other vertex of the square. This is a dynamic programming way solution to this problem. To analyze, the time complexity of this way is O(mn) and the space complexity is also O(mn). Well, can we do better? Sure, notice that when we compute the dp, we only care about the previous element to this position and (i - 1)th row. That is to say, we do not need a matrix to store dp at all. Instead, we only need a 1D array for dynamic programming, then the space complexity can become O(n).]]></content>
      <categories>
        <category>LeetCode</category>
        <category>dynamic programming</category>
      </categories>
      <tags>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dynamic Programming]]></title>
    <url>%2F2019%2F07%2F07%2FDynamic-Programming%2F</url>
    <content type="text"><![CDATA[Those who cannot remember the past are condemned to repeat it. Starting From Fibonacci NumberFibonacci Number is a series of number satisfying $F(n) = F(n - 1) + F(n - 2)$, for examaple, {0, 1, 1, 2, 3, 5, 8, 13…}. Intuitively, we may resort to recursive approach to this problem. Thought it is pretty straightforward, the ineffiecient recursive call takes the cost of your computational time. So, why is that ? Let’s think about the structure of the call tree. Each fibonacci number relies on the computing of the other two fibonacci number ahead of it. The image before shows the call tree when you get the input as 6 and it is not hard to realize that the tree will have $2^n$ nodes in total with the depth n. The essence of the inefficiency of this approach lies in that we can compute the same fibonacci number (e.g. fib(3) for 3 times) for multiple times which is totally unnecessary. So here is where the Memoization comes in to resue. Top-Down MemoizationAs we have seen the above case, the issue is that the subproblems of the whole problem overlap in some parts leading to ineffecient and unnecessary recalculation. Then how to fix it ? Well, it is quite simple, we trade space with time by keeping a table to record the work you’ve done and you can just return the answer if the subproblem has already been done once. That is roughly the basic idea of Memoization. In general, top-down Memoization is that you start solving the whole problem by breaking it into pieces. Return the solution recorded if the subproblem has already been solved once or solve the subproblem for once otherwise. Ok, now let’s take a deeper look by comparing the memoization approach and non-memoization approach in the context of the fibonacci problem. First, the time complexity. For the non-memoization approach, the time complexity is $O(2^n)$ while for the memoization approach is $O(n)$ which is much better. Then for the space complexity. Remember, space complexity takes any memory you use into account including the call stack. Thus, the space complexity of non-memoization approach is $O(n)$ (e.g. fib(6) - fib(5) - fib(4) - fib(3) - fib(2) - fib(1), the fib(6) has not called fib(4) yet) and it is the same for the memoization approach too (memory for record table). Down-Top TabulationDifferent from Memoization, tabulation solves the problem by starting from the most trivial subproblem, upwards to the top. Let’s look at an example to see how this works. Calculate the total number of possible path to the destination in the image Divide the Problem RecursivelyTo analyze this problem, the green guy can simply walk downwards or to the right (you know, it will be stupid to turn back (i.e. to the left and upwards)). Thus, we can divide this problem as separate steps along path as below.&emsp;&emsp;&emsp;$Path(start, end) = Path(A, end) + Path(B, end) = …$ Memoization vs. RecursionWe can see from the image above that Path(C, end) will be calculated twice and so are others, which is fairly inefficient. That is because there are overlapping between some subproblems. Thus we can take the Memoization approach to make sure each subproblem solved only once. To do this, we can use a table to record the total number of paths from a specific point to the end. Start by the Most Trivial ProblemDynamic Programming solves problem from down to top. This idea applies here as well. Instead of starting from the start point, we can think of this problem from the end point backwards.&emsp;&emsp;&emsp;$Path(P, end) = Path(P’s\ right, end) + Path(P’s\ down, end)$Thus, we can compute the whole table from the right to left and then down to up. SummaryIn a nutshell, dynamic programming is suitable for the situation where you can divide problem into sub-problems which can be broken down to smaller sub-problems and there is overlapping in solving the sub-problems. It is efficient by only computing the overlapping part once. Basically, optimization and combinatorial problems are of the two most typical problem of dynamic programming problems. The optimization problem requires you to find a feasible solution so that the objective function can be optimized while the combinatorial problems want you to compute the number of ways to do something or possibility of some event happening. Do note that similar to divide-and-conquer though it is, dynamic programming is better when there is overlapping between the subproblems while the divide-and-conquer doesn’t. Problem Number in LeetCode#53 (Maximum Subarray)#62 #63 #64 (Path Stuff)#70 (Climbing Stairs)#123 (Best time to buy and sell III)#174 (Dungeon Game) For boundary, can assign dp[m+1][n+1] instead of dp[m][n]#198 #213 (House Robber) dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])#264 (Ugly Number) (nth ugly numbe = min(2*ugly[i2], 3*ugly[i3], 5*ugly[i5]))#300 (Longest Increasing Subsequence) DP with binary search#303 (Range Sum Query) #304 (Range Sum Query - 2D)#322 (Coin Change)#329**(Longest Increasing Path In a Matrix) DFS or BFS#338 (Counting Bits)#343 (Integer Break)#357 (Count Numbers with Unique Digits)#413 (Arithmetic Slices)#416 (Partition Equal Subset Sum) =&gt; dp[i] whether sum i can be achieved = dp[i] || dp[i - num]#552 (Student Attendance Record II)#746 (Min Cost Climbing Stairs) Reference:&emsp;youtube - Algorithms: Memoization and Dynamic Programming&emsp;An intro to Algorithms: Dynamic Programming&emsp;Tutorial For Dynamic Programming]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
</search>
