<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[CS61B-2: Bits, Type, Lists, Sets]]></title>
    <url>%2F2019%2F07%2F06%2FCS61B-2-Bits-Type-Lists%2F</url>
    <content type="text"><![CDATA[Arrays have a fixed size ?Then come Lists ! BitsMemory is stored as a sequence of 0 and 1 and bits Interpreted using types Variable Types 8 primitive types: byte, short, int, long, float, double, char, boolean Reference Types Golden Rule of Equals x = y =&gt; copy the bits from y to x Parameter Passing =&gt; just copy the bits (pass by value always) Object Instantiation Declaring a Variable (primitive type)1. Set aside memory (Java will set aside exact bits to hold a thing of type)2. Create an entry in an internal table that maps variable name to the location of the first bit in the box by Java Interpreter☑️ Java does not write anything to reserved boxes when declaring variables (no default values)☑️ Java does not allow accessing a variable uninitialized Reference Variables declaration1. Allocate a box of 64 bits2. Address of instance returned by new operator and bits copied into boxNull == all zeros Using new keyword1. Allocates a box for each instance variable of the class and fills them with a default value.2. Constructor then usually fills every box with some other value(In real Java, there is additional overhead for any object) Arrays Instantiation Arrays Structure A fixed integer length N A sequence of N memory boxes where all boxes are of the same type (0 thru N - 1) Array Creation 123x = new int[3]; // each box filled a default value (e.g. 0) y = new int[]&#123;1, 2, 3, 4, 5&#125;; // specified starting valuesint[] z = &#123;9, 10 ,11, 12, 13&#125;; // declare and create z, omit new keyword (only used with declaration) Copy Array123//faster than copying item by item using loopSystem.arraycopy(srcArray, startPosInSrc, targetArray, startPosInTarget, lenToCopy)e.g System.arraycopy(b, 0, x, 3, 2); // b &#123;9, 10, 11&#125;, x &#123;1, 2, 3, 4, 5&#125; -&gt; &#123;1, 2, 3, 9, 10&#125; Java Arrays only perform bounds checking at runtime 2D Arrays – Array of Array References1234int[][] bamboozle = new int[4][]; // create an array of int arrays (4 memory boxes, each points to an array of int(unspecifid length)), only 1 array createdint[][] bamboozle = new int[4][4]; // create 5 arraysint[] rowZero = bamboozle[0];int[][] x = &#123; &#123;1, 2, 3&#125;, &#123;4, 5, 6&#125;, &#123;7, 8&#125; &#125;; Basic Int Linked List&emsp;Naked recursive data structure 1234567891011121314151617public class IntList &#123; public int first; public IntList rest; public IntList(int f, IntList r) &#123; first = f; rest = r; &#125; /** Return the size of the list using... recursion! */ public int size() &#123; if (rest == null) &#123; return 1; &#125; return 1 + this.rest.size(); &#125;&#125; Singly Linked List (SLList) Improvement #1: Rebranding &emsp;Rename IntList class to IntNode class Improvement #2: Bureaucracy &emsp;IntNode is hard to work with =&gt; create a separate class called SLList &emsp;SLList as a middle man between user &amp; naked recursive data structure Improvement #3: Public vs. Private &emsp;Declare first variable of SLList class as private &emsp;&emsp;=&gt; inaccessible naked data structure Improvement #4: Nested Classes &emsp;Embed a class declaration inside of another Static Nested classesWhen nested class never use any instance members of the outer class =&gt; can not access any of the members of the enclosing classSave small amount of memory Improvement #5: addLast(), size() and Caching Recursive Approach of size() Slow method for long list (scan thru the whole list) 1234567891011/** Returns the size of the list starting at IntNode p. */private static int size(IntNode p) &#123; if (p.next == null) &#123; return 1; &#125; return 1 + size(p.next);&#125;public int size() &#123; return size(first);&#125; OverLoaded Method Two methods with the same name but different signatures Caching Add a size variable to track the current size Increase memory usage and slow down add method Improvement #6: The Empty List&emsp;Constructor to create an empty list (first = null; size = 0)&emsp;&emsp;=&gt; addLast Null Pointer Excep&emsp;SLList with Sentinel Node Doubly Linked List (DLList) Limitations of SLList and FixLimitation and Reason =&gt; Slow method for long list (scan thru the whole list)Approach #1: add a last variable&emsp;Limitations: addLast () and getLast () will be fast but removeLast () will be&emsp;slow (to get second-to-last node) &emsp;&emsp; Approach #2: Looking Back – Doubly Linked List&emsp;&emsp; Add a previous pointer to each node, 2 links for each node &emsp;&emsp; Limitation: last pointer sometimes points at the sentinel node and sometimes a&emsp;&emsp; real node =&gt; getLast() method wrong Improvements: Sentinel UpgradeApproach #1: add a second sentinel node &emsp;&emsp; Approach #2: Circular List&emsp;&emsp; front and back pointer sharing the same sentinel node Generic Lists (e.g. DLLists) Limitations of the Above ListsThey can only hold integer values Generics Declaration Syntax123public class DLList&lt;T&gt; &#123; public T item;&#125; Instantiation Syntax 1DLList&lt;String&gt; d2 = new DLList&lt;&gt;(“hello”); Syntax Details ☑️Generics only work with reference type; ☑️Empty diamond operator can be used during instantiation if declaration happens at the same line (but can also declare the type inside of the angle brackets during instantiating) ArrayList Linked List Performance of get(i)Linear in the size of the entire listSlow for random access =&gt; use array instead Array ResizingApproach #1: add more size at once =&gt; slowApproach #2: multiply size by 2 (scaling factor) – Geometric Resizing Improvement: Spike of eventsUsage ratio = size of the list / length of the arrayHalf the size when ratio &lt; 0.25 Generic AList12Glorp[] items = new Glorp[8]; // Wrong! Generic Type cannot be instantiated directly !Glorp[] items = (Glorp[]) new Object[8]; // Right ! only a compilation warning Nulling out deleted items for generics objects to avoid loitering (Java only destroys (garbage collects) object when the last reference has been lost) List and Set in Real World ListInterface: java.util.ListImplementations: java.util.ArrayList, java.util.LinkedList SetSets – a collection of unique elements, no sense of orderInterface: java.util.SetImplementations: java.util.HashSet, java.util.TreeSet Reference:&emsp;berkeyley-cs61b]]></content>
      <categories>
        <category>CS61B</category>
        <category>Lecture Notes</category>
      </categories>
      <tags>
        <tag>Bits</tag>
        <tag>Type</tag>
        <tag>LinkedList</tag>
        <tag>ArrayList</tag>
        <tag>Set</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Knuth-Morris-Pratt(KMP) Algorithm]]></title>
    <url>%2F2019%2F07%2F06%2FKnuth-Morris-Pratt-KMP-Algorithm%2F</url>
    <content type="text"></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>KMP</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Big Data Analytics]]></title>
    <url>%2F2019%2F07%2F06%2FBig-Data-Analytics%2F</url>
    <content type="text"></content>
      <categories>
        <category>CC</category>
        <category>Big Data Analytics</category>
      </categories>
      <tags>
        <tag>sequential analytics</tag>
        <tag>MapReduce</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git: Local & Remote Repo]]></title>
    <url>%2F2019%2F07%2F06%2FGit-Local-Remote-Repo%2F</url>
    <content type="text"><![CDATA[Git &amp; Local Repos Version Control System&emsp;Track the history of code revision&emsp;Git is a distributed version control system&emsp;&emsp;&emsp;each developer’s computer store the entire history&emsp;Repository = entire history of an entire project Git Config12$ git config –global user.email “you@xxx.edu”$ git config -global user.name “your name” Local Repositories12345678$ cd to directory$ git init # tell the version control system that we want to track history of directory but nothing is stored in the repository at this point$ git add ./blahblah # store things in the repository, but still nothing stored yet, just add files to the list of files to track (you may not want to track all files in directories)$ git status # changes to be committed (list files trakced and whose changes ready to be committed) / untracked files$ git commit -m “add some stuffs” # stick copies of files into the repository / -m add message to the commit$ git log # see evidence of snapshot (commit ID)$ git show commitID # peek inside of the commit$ git checkout commitID filepath # roll back files but does not change the commit history / checkout auto does a git add on roll back files Local Repositories (Technical Overview) Initializing Local Repositories&emsp;Repositories: store files as well as history of changes to files&emsp;Initialize git repositories -&gt; create a .git subdirectory (store metadata as&emsp;well as old the actual snapshots of the files) Tracked vs Untracked Files&emsp;Tracked Files: been added to git repository&emsp;Untracked Files: never been tracked or removed from tracking (git not keep history) Staging &amp; Committing&emsp;commit =&gt; specific snapshot of working directory (users specify what composes the snapshot by staging file) Undoing Changes&emsp;Unstage a file1$ git reset HEAD [file] # unstage a file that you have not yet committed (leave changes intact) &emsp;Amend latest commit (change message or add forgotten files)12$ git add [forgotten-files]$ git commit –amend # This commit will replace previous commit &emsp;Revert a file to its state at the time of the most recent commit1$ git checkout -- [file] Git &amp; Remote Repo Remote Repositories&emsp;Store copies of your repositories on computers other than yours&emsp;By convention the name of the primary remote is called origin Remote Add12345$ git remote add [remote-repo-name] [remote-repo-URL] # record a new location for network data transfere.g. $ git remote add origin https://github.com/.......$ git remote rename [old-name] [new-name] # rename the repo$ git remote rm [remote-name] # remove the repo$ git remote -v # list all locations for network data transfer Cloning a Remote1$ git clone [remote-repo-URL] # make a copy of repository and record the URL of the remote repo for network data transfer and name it as origin Pushing Commits12$ git push [remote-name] [remote-branch] # push commits to GitHube.g. $ git push origin master Fetching &amp; Pulling Commits12$ git fetch [remote-name] # only update your local copy of the remote code but not merge the changes into your own code $ git pull [remote-repo-name] [remote-branch-name] # get the most recent copy of the files as seen in remote-repo-name (== fetch + merge, also merge the changes into your HEAD branch) Git Branching Intro&emsp;Branches =&gt; allow keeping track of multiple different versions of work&emsp;Git data structure is a graph (branch pointers and commits as nodes) Creating, Deleting &amp; Switching Branches&emsp;HEAD pointers references the branch you currently have and Branching&emsp;instructions modify branches and change what HEAD points to 12345$ git branch [new-branch-name] # create a branch off of your current branch$ git checkout [destination-branch] # switch branches$ git checkout -b [new-branch-name] # create a new branch and switch to it$ git branch -d [branch-to-delete] # delete a branch$ git branch -v # figure out which branch you are on Merging (Merge one branch into another) command12$ git checkout master $ git merge [other-branch-name]. # merge the other branch into master &emsp;this will create a new commit that joins two branches and change each pointer to this new commit / first parent–commit on the master branch / second parent–other branch Merge Conflicts and Resolving If commits on the two branches changed the same files (Sometimes conflict can not be resolve =&gt; will present both changes from the different branches) Git tells which files have conflict =&gt; open files =&gt; resolve manually =&gt; commit 2 segments of code&emsp;Top code snippet =&gt; branch originally had checked out when running merge command =&gt; called HEAD&emsp;Bottom code snippet =&gt; branch you were merging into your checked out branch Reference:&emsp;berkeyley-cs61b-lab1&emsp;git documentation]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS61B-1:Java Intro, Classes]]></title>
    <url>%2F2019%2F07%2F05%2FCS61B-1-Java-Intro-Classes%2F</url>
    <content type="text"><![CDATA[Running a Java Program .java-&gt; javac (compiler) -&gt; .class (Java bytecode) -&gt; java (Interpreter) -&gt; runs .class file 1. safer (type checked) 2. faster (for machine to execute) 3. protect intellectual property Static Typing Statically Typed language&emsp;All Variables have a declared type and type can never be changed&emsp;Expressions have a type&emsp;Compiler will check and make sure the type right before the program runs Pros and Cons Pros catch certain types of errors type errors never occur on end users easier to read and reason about the code run efficiently (no runtime type checking) Cons code is more verbose code is less general but it can be solved by generics Static vs. Non-Static Instance Variables and Object Instantiation&emsp;Problem: Not all objects of a class are equal&emsp;&emsp;=&gt; Approach1: create separate classes for each =&gt; redundancy&emsp;&emsp;=&gt; Approach2: classes instantiated and instances hold data&emsp;&emsp;&emsp;&emsp;e.g. Type ins = new Type();&emsp;Instance Members (Variables/Methods) = Non-Static Members (Variables/Methods) Constructors&emsp;Parameterized instantiation Class (Static) Methods VS Instance (Non-Static) Methods Static Methods&emsp;invoked using the class name Static Variables&emsp;properties inherent to class itself&emsp;accessed using name of class Instance Methods&emsp;actions that can be taken only by a specific instance of a class&emsp;Keyword this to refer to the current object Arrays of Object 2 steps of initializing arrays&emsp;=&gt; First use new keyword to create the array (Dog[] dogs = new Dog[2])&emsp;=&gt; then use new again for each object that you want to put into the array The array index starts at 0 in Java Array.length Alternate way of defining array&emsp;int[] numbers = new int[] {4, 7, 10}; Summary of Terminology Instance Variables (Properties) Non-static Methods (Instance Methods) Constructors (How to instantiate the class)Declaration + Instantiation + Assignment + Invocation of Methods Reference:&emsp;berkeyley-cs61b]]></content>
      <categories>
        <category>CS61B</category>
        <category>Lecture Notes</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Git</tag>
        <tag>Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F04%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Others</category>
      </categories>
  </entry>
</search>
