<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCode #123 Best Time to Buy and Sell Stock III]]></title>
    <url>%2F2019%2F07%2F09%2FLeetCode-123%2F</url>
    <content type="text"><![CDATA[Input is an array for which the ith element is the price of a given stock on day i.Find the maximum profit. You may complete at most two transactions.Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again). Example 1:Input: [3,3,5,0,0,3,1,4]Output: 6Explanation: Buy on day 4 (price = 0), sell on day 6 (price = 3), profit = 3-0 = 3.Then buy on day 7 (price = 1), sell on day 8 (price = 4), profit = 4-1 = 3. This is a hard-level problem on the LeetCode, which takes me much time to think about. Thus, I’d like to write this post to review this problem. Basically, we can imagine this as two separate purchase-selling process, i.e. [first buy …. first sell] [second buy …. second sell]. It is worth noting that second buy happens only after the first sell. In this way, we can turn this two processes into one-time purchase-selling process which the price on i-th day takes the maximum profits before day i into account.&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;$newPrices[i] = prices[i] - maximum\ Profit\ of\ first\ buy$Using dynamic programming algorithm, the implementation is shown as below. 12345678910111213141516171819202122232425class Solution &#123; public int maxProfit(int[] prices) &#123; if (prices == null || prices.length &lt;= 1) &#123; return 0; &#125; int maxProfit = 0; int minCost = prices[0]; int[] dp = new int[prices.length]; dp[0] = prices[0]; // compute the newPrice and store the record in dp[] for (int i = 1; i &lt; prices.length; i++) &#123; minCost = Math.min(minCost, prices[i]); maxProfit = Math.max(maxProfit, prices[i] - minCost); dp[i] = prices[i] - maxProfit; &#125; maxProfit = 0; minCost = prices[0]; // find the max profit as you only buy once for (int i = 0; i &lt; prices.length; i++) &#123; minCost = Math.min(minCost, dp[i]); maxProfit = Math.max(maxProfit, prices[i] - minCost); &#125; return maxProfit; &#125;&#125; The above implementation takes two pass. However, if we look a little deeper, we can find that the two pass can actually be combined as one like below. 123456789101112131415class Solution &#123; public int maxProfit(int[] prices) &#123; int sell1 = 0; // maximum profit after first sell int sell2 = 0; // total maximum profit after second sell int buy1 = Integer.MAX_VALUE; int buy2 = Integer.MAX_VALUE; for (int i = 0; i &lt; prices.length; i++) &#123; buy1 = Math.min(buy1, prices[i]); sell1 = Math.max(sell1, prices[i] - buy1); buy2 = Math.min(buy2, prices[i] - sell1); sell2 = Math.max(sell2, prices[i] - buy2); &#125; return sell2; &#125;&#125; Well, I think the above approach is the most compact way to solve this while I think there are other perspectives to look at this problem. For instance, using DP, you can build two arrays, one to store the maximum profit of one buy-sell before day i and one for after day i. We just find the Max(Sum(two arrays)) to solve this problem.]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS61B-4]]></title>
    <url>%2F2019%2F07%2F08%2FCS61B-4%2F</url>
    <content type="text"><![CDATA[Generics and Autoboxing Automatic Conversions Autoboxing and UnboxingCannot provide primitive type as an actual type argumentUse corresponding reference type (wrapper classes)Java implicitly convert between primitive and wrapper typesArrays are never auto-boxed or auto-unboxed&emsp;&emsp;e.g. Integer[] x = (int[]) x; (compiler not allowed)autoboxing and unboxing has a measurable performance impact wrapper types use much more memory than primitive types&emsp;&emsp;every object has a 64 bit refetrence variable and requires 64 bits of&emsp;&emsp;overhead to store things like the dynamic type of the object WideningJava automatically widen a primitive if neededVariable of type T1 will be implicitly cast to type T2 which takes a wider range of values than T1 (e.g. int =&gt; double)Have to manually cast when going from a wider type to a narrower type&emsp;&emsp;e.g. double x = 20; int y = (int) x; Immutabilityimmutable data type: cannot change in any observable way after instantiation&emsp;&emsp;e.g. String =&gt; remain unchanged after calling any method on Stringany data type with non-private variables is mutable unless declared final(final: prevent the variable from being changed after first assignment) Prosprevent bugs and makes debugging easier (properties cannot change)can count on objects to have a certain behavior/trait Consneed to create a new object in order to change a propertyDeclare a reference as final does not make the object that reference is pointing to immutableReflection API possibly change even the private variables Generics - Maps&lt;K, V&gt; Compilation error: assertEquals ambiguous 1234ArrayMap&lt;Integer, Integer&gt; am = new ArrayMap&lt;&gt;();am.put(2,5);int expected = 5;assertEquals(expected, am.get(2)); This is because assertEquals is overloaded, e.g. assertEquals(int expected, int actual), assertEquals(Object expected, Object actual) =&gt; Java does not know which method to call. Generic Methodsgenerics defined in class header (share with all methods) =&gt; Java wait for user to instantiate an object of the class in order to know the actual type ☑️Declare method as generic 1public static &lt;K, V&gt; V get(Map61B&lt;K, V&gt; map, String key) &#123;...&#125; The only issue here is that for maxKey(Map61B), “&gt;”operator only works for primitive. Then we can think of using .compareTo() method instead. But ! not all objects have .compareTo() method. Here, we declare it as K extends Comparable, this means that keys must implement the comparable interface. In the end we declare this method as below. 1public static &lt;K extends Comparable&lt;K&gt;, V&gt; V get(Map61B&lt;K, V&gt; map, String key) &#123;...&#125; ☑️Type Upper Bounds Extends in the above context simply states a fact that K must be a Comparable instead of giving K the abilities of a Comparable Summary of genericsAutoboxing and auto-unboxingPromotion/Widening between primitive typesGeneric types for methods (before return type)Type upper bounds in generic methods ExceptionsException breaks normal flow of control, handling error. Throw ExceptionsExceptions are objects in Javathrow new ExceptionObject(para1,…) Catching Exceptionstry and catch breaks the normal flow of the program&emsp;&emsp;protect program from exceptions&emsp;&emsp;corrective action&emsp;&emsp;keep error handling separate from the rest of the program 12345678910111213141516171819func readFile: &#123; try &#123; open the file; determine its size; allocate that much memory; read the file into memory; close the file; &#125; catch (fileOpenFailed) &#123; doSomething; &#125; catch (sizeDeterminationFailed) &#123; doSomething; &#125; catch (memoryAllocationFailed) &#123; doSomething; &#125; catch (readFailed) &#123; doSomething; &#125; catch (fileCloseFailed) &#123; doSomething; &#125;&#125; Uncaught ExceptionsException thrown =&gt; descends the call stack =&gt; bottom of the stack =&gt; crash and print out the stack trace Checked vs. Unchecked Exceptions Compilation ErrorException must be caught or declared to be thrown&emsp;=&gt; Compiler thinks some exceptions must be handled Checked ExceptionsMust be handled2 ways to handle checked error&emsp;Catch: handle it right now&emsp;Specify: defer handling &amp; mark methods as dangerous 123456public static void dangerMethod() throws IOException &#123;…&#125;public static void main (String[] args) &#123; // main method is also dangerous by calling gulgate // handle it by try-catch or specifying gulgate()&#125; Unchecked Exceptions Not need to be handle and compile just fine but may crash at runtime Include Error &amp; RuntimeException (unknown till runtime &amp; unrecoverable) Iteration Enhanced For Loop 12345Set&lt;String&gt; s = new HashSet&lt;&gt;();...for (String city : s) &#123;...&#125; The above code translate to 1234567Set&lt;String&gt; s = new HashSet&lt;&gt;();...Iterator&lt;String&gt; seer = s.iterator();while (seer.hasNext()) &#123; String city = seer.next(); ...&#125; Iterator IterableCollection extends the Iterable interfaceEnhanced for loop works on object implementing iterable123public interface Iterable&lt;T&gt; &#123; Iterator&lt;T&gt; iterator();&#125; Iterator1234public interface Iterator&lt;T&gt; &#123;boolean hasNext(); T next();&#125; It will throw NoSuchElementException if user calls next() when hasNext() should return falseCan make a nested class implementing the Iterator Iterable vs. IteratorIterable =&gt; the object on which the iterator is performingIterator =&gt; defines methods which actually do the iteration Object MethodsAll classes extend from the Object class. toString() gives String representation of the object System.out.print() implicitly calls the method By default, Object class prints out the address of the object (hexadecimal String) String ‘+’ operator return a new String each time which take time linearly in the length of the whole String &emsp;&emsp;=&gt; use StringBuilder which is mutable equals(Object o) == operator== checks if two variables hold the same bitsif equal for primitive and if address equal for reference equals(Object o)By default, it is the same as == if not overridenChecks if null or other class (.getClass()) or the same address (i.e. the same object) Packages and Access Control Packages Package - namespace organizing classes and interfaceIssue: multiple classes with the same nameSolution: Appending class with a website address(backwards)&emsp;&emsp; e.g. ug.joshh.animal; // website is josh.ug Using Packages 1. Access within the same package &emsp;&emsp;Use the class name 2. Outside the package &emsp;&emsp;Use entire canonical name or import package and use simple name &emsp;&emsp;Wildcard import &emsp;&emsp;&emsp;&emsp;e.g. import ug.joshh.animal.* &emsp;&emsp;&emsp;&emsp;//danger: conflicts for multiple packages with same class Creating a Package 1. Put the package name at the top of each file 2. Store the file in the folder that has the appropriate folder name. &emsp;&emsp;e.g. ug.joshh.animal =&gt; ug/joshh/animal folder Create a Package in IntelliJ File -&gt; New Package -&gt; choose package name Add New Java Files to a Package in IntelliJ Right-click package name -&gt; New -&gt; Java Class Add Old Java Files to a Package in IntelliJ Add “package [name]” to the top of file -&gt; move .java file into folder Default Packages – class with no package name at the top JAR Files Zip all files by creating a JAR file (contain all .class file with additional info) JAR file is not safe =&gt; possible to unzip back into .java files Creating a JAR File in IntelliJ1. File -&gt; Project Structure -&gt; Artifacts -&gt; JAR -&gt; “From modules with dependencies”2. Ok multiple times3. Build -&gt; Build Artifacts (create a JAR file in a folder called “Artifacts”) Build Systems – Automate the setting up of project structure Maven, Ant, Gradle Access Control Package Private (black box) &emsp;&emsp;default access given to Java memebers without explicit modifier &emsp;&emsp;accessible between the same package (including default package) Public &emsp;&emsp;Signature should not change once deployed, if developers want to &emsp;&emsp;cancel public things, they call it deprecated Subtleties &emsp;&emsp;Access is based only on static type &emsp;&emsp;Default access mode for Interface is public not package private 123456789101112131415package universe;class HasHair implements BlackHole &#123; Object[] items; public void add(Object o) &#123; ... &#125; public Object get(int k) &#123; ... &#125;&#125;import static CreationUtils.hirsute;class Client &#123; void demoAccess() &#123; BlackHole b = hirsute(); HasHair hb = (HasHair) b; // HasHair is package private, this package does not see the existence of HasHair &#125;&#125; Reference:&emsp;berkeyley-cs61b]]></content>
      <categories>
        <category>CS61B</category>
        <category>Lecture Notes</category>
      </categories>
      <tags>
        <tag>Autoboxing</tag>
        <tag>Widening</tag>
        <tag>Immutability</tag>
        <tag>Generic Method</tag>
        <tag>Type Upper Bounds</tag>
        <tag>Exception</tag>
        <tag>Iteration</tag>
        <tag>Object Class</tag>
        <tag>Package</tag>
        <tag>Access Control</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS61B-3:Testing, Inheritance, Interface, Extends, Comparable, Comparator, ADTs, Abstract Class]]></title>
    <url>%2F2019%2F07%2F08%2FCS61B-3%2F</url>
    <content type="text"><![CDATA[Testing Junit TestingLibrary =&gt; org.junit Junit Methods1org.junit.Assert.assertArrayEquals(expected, input); https://junit.org/junit4/javadoc/4.12/org/junit/Assert.html Test Annotation@org.junit.TestEach test method can only be non-static12import org.junit.Testimport static org.junit.Assert.* Advantages 1. No manually test invoking 2. If one fails, the other still runs 3. Error msg much nicer to look Unit Testing vs. Integration Testing Test-Driven Development (TDD) Selection Sort Steps (Select Smallest + Swap)1. Find the smallest item2. Move it to the front3. Selection sort the remaining N – 1 items (without touching the front item)e.g. {6, 3, 7, 2, 8, 1} =&gt; {1, 3, 7, 2, 8, 6} =&gt; …… Inheritance, Interface Hypernyms, Hyponyms and Inheritance Hypernyms =&gt; superclass Hyponyms =&gt; subclass Interface =&gt; only provide what to do but not implementation (how to do) Interface Inheritance Subclass inherits all the methods/behaviors of the superclass Multi-generational (Alist -&gt; List -&gt; Collection) Implementation Inheritance default keyword specified in method signature in interface, method still overridable &emsp;e.g. default public void print() {…} Method Overloading vs Method Overriding Overloadingmultiple methods with the exact same name and different parameters 123e.g. default void flatter (Animal a); // Interface void flatter(Dog a); // subclass// It is an overloading not an overriding OverridingSubclass has a method with the same signature as in the superclass@Override tag =&gt; compiler error when making typos on signatureNo override for static method, only for instance method Dynamic Method Selection Static type =&gt; declared at compile time and never changes Dynamic type =&gt; equal to the type of object it is currently referring to at run time, specified at instantiation (new) Method Selection Algorithm 1foo.bar(x) // foo is of type TPrime and x is of type T1; compile time =&gt; the compiler verifies TPrime has a method that can handle T1 and records the signature of this method (if there are multiple methods, compiler will record the most specific one. e.g. bar(Dog) ☑️ vs. bar(Animal))runtime =&gt; if foo’s dynamic type overrides the recorded signature, then use the overridden method Puzzlethere 2 methods in the same class 123456public static void peek(List61B&lt;String&gt; list) &#123; System.out.println(list.getLast());&#125;public static void peek(SLList&lt;String&gt; list) &#123; System.out.println(list.getFirst());&#125; Run the following code 12345SLList&lt;String&gt; SP = new SLList&lt;String&gt;();List61B&lt;String&gt; LP = SP;SP.addLast("elk");peek(SP);peek(LP); The first call to peek() will use the second peek (cause it chooses the most specific one), the second call will use the first peek. Extends – hierarchical relationship between classes Extends Keyword MembersSubclasses inherit all members of the parent class (instance and static vars / methods / all nested classes), private members cannot be directly accessed by subclasses Constructorconstructors are not inheritedall constructor must start with a call to one of superclass’s constructors explicit call =&gt; super() or Java automatically make a call to superclass’s no-argument constructor if having one-argument constructor =&gt; use super(x)(implicit call not work) invoke superclass’s method by super.methodname() Object ClassEach class is a descendant of the Object class (explicitly or implicitly extends), inheriting all members of Objects. But interface not extends object class Membershttps://docs.oracle.com/javase/8/docs/api/java/lang/Object.html.equal(Object obj).hashCode().toString() Encapsulation Basic ideaprograms should be built into modular, interchangeable pieceshiding information that others do not need Hierarchical abstractionAbstraction barriers – users not observe the internal working Design for change Inheritance breaks encapsulatione.g. Two methods A and B combined to achieve one functionality, but may by A calling B or B calling A to complete this. If one of them is overridden, sth wrong may happen Type Checking and CastingCompiler only allows method calls and assignments based on compile-time types ExpressionsExpressions using the new keywork also have compile-time typesMethod calls have compile-time types equal to their declared type CastingTell the compiler that a specific expression has a specific compile-time typeOnly matters with compile time and may cause runtime exceptions Higher Order Functions (HoF)HoF is a function that treats other functions as data (parameters)In Java7 and earlier, variables could not contain pointers to functions (no type for fcts)=&gt; take advantage of interface inheritance=&gt; an interface defining the function (defining a function type) and a class which implements this interface to represent a concrete function 123456789101112public interface IntUnaryFunction &#123; int apply(int x);&#125;public class TenX implements IntUnaryFunction &#123; /* Returns ten times the argument. */ public int apply(int x) &#123; return 10 * x; &#125;&#125;public static int do_twice(IntUnaryFunction f, int x) &#123; return f.apply(f.apply(x));&#125; Subtype Polymorphism Polymorphism Allows routines to use variables of different types TypesParametric Polymorphism (aka Generics)Subtype Polymorphism =&gt; due to inheritance An example of printing the larger of the two objectsExplicit HoF Approach=&gt; need a common way to achieve functionality 1234def print_larger(x, y, compare, stringify): if compare(x, y): return stringify(x) return stringify(y) &emsp;&emsp;Subtype Polymorphism Approach =&gt; object itself makes the choice =&gt; function &emsp;&emsp;is called dependent on what objects are 1234def print_larger(x, y):if x.largerThan(y): return x.str()return y.str() Comparable InterfaceCompare myself to another object =&gt; embedded within the object itselfDefines the natural ordering of type =&gt; only room for one compareTo method compareTo(T obj) return negative number if this &lt; o; return 0 if this equals to o; return positive number if this &gt; o; (return this.something – o.something) Comparator Interface A third party machine that compares two objects to each other Can define multiple ways to compare (e.g. size, name ….) compare(T o1, T o2)return negative number if o1 &lt; o2;return 0 if o1 equals to o2;return positive number if o1 &gt; o2; 123456789101112131415161718import java.util.Comparator;public class Dog implements Comparable&lt;Dog&gt; &#123;... public int compareTo(Dog uddaDog) &#123; return this.size - uddaDog.size; &#125; private static class NameComparator implements Comparator&lt;Dog&gt; &#123; public int compare(Dog a, Dog b) &#123; return a.name.compareTo(b.name); &#125; &#125; public static Comparator&lt;Dog&gt; getNameComparator() &#123; return new NameComparator(); &#125;&#125; Java Libraries and packages Abstract Data Types (#ADTs)Defined only by its operations but not by its implementationIn Java, aka interface java.util libraryList: an ordered collection of itemsSet: an unordered collection of strictly unique itemsMap: a collection of key/value pairs Java Features Take less time to write programStatic Types (type checking and help guide programmers)Bias to interface inheritance =&gt; cleaner subtype polymorphismAccess control modifiers =&gt; abstraction barriers more solid More efficient codeMore control over engineering tradeoffsSingle valued arrays =&gt; better performance Basic structure =&gt; more closely resemble underlying hardware Interface vs. Abstract Class InterfaceAll methods must be public (redundant)All variables must be public static final&emsp;Can never be changed&emsp;No instance variablesCannot be instantiatedAll methods are by default abstract unless specified to be defaultCan implement more than one interface per class Abstract Class (lie between interfaces and concrete classes)Method can be public or privateCan have any types of variablesCannot be instantiatedMethods are by default concrete unless specified to be abstractCan only implement one per class Reference:&emsp;berkeyley-cs61b]]></content>
      <categories>
        <category>CS61B</category>
        <category>Lecture Notes</category>
      </categories>
      <tags>
        <tag>Testing</tag>
        <tag>Inheritance</tag>
        <tag>Interface</tag>
        <tag>Extends</tag>
        <tag>Comparable, Comparator</tag>
        <tag>ADTs</tag>
        <tag>Abstract Class</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dynamic Programming]]></title>
    <url>%2F2019%2F07%2F08%2FDynamic-Programming%2F</url>
    <content type="text"><![CDATA[Those who cannot remember the past are condemned to repeat it. Starting From Fibonacci NumberFibonacci Number is a series of number satisfying $F(n) = F(n - 1) + F(n - 2)$, for examaple, {0, 1, 1, 2, 3, 5, 8, 13…}. Intuitively, we may resort to recursive approach to this problem. Thought it is pretty straightforward, the ineffiecient recursive call takes the cost of your computational time. So, why is that ? Let’s think about the structure of the call tree. Each fibonacci number relies on the computing of the other two fibonacci number ahead of it. The image before shows the call tree when you get the input as 6 and it is not hard to realize that the tree will have $2^n$ nodes in total with the depth n. The essence of the inefficiency of this approach lies in that we can compute the same fibonacci number (e.g. fib(3) for 3 times) for multiple times which is totally unnecessary. So here is where the Memoization comes in to resue. Top-Down MemoizationAs we have seen the above case, the issue is that the subproblems of the whole problem overlap in some parts leading to ineffecient and unnecessary recalculation. Then how to fix it ? Well, it is quite simple, we trade space with time by keeping a table to record the work you’ve done and you can just return the answer if the subproblem has already been done once. That is roughly the basic idea of Memoization. In general, top-down Memoization is that you start solving the whole problem by breaking it into pieces. Return the solution recorded if the subproblem has already been solved once or solve the subproblem for once otherwise. Ok, now let’s take a deeper look by comparing the memoization approach and non-memoization approach in the context of the fibonacci problem. First, the time complexity. For the non-memoization approach, the time complexity is $O(2^n)$ while for the memoization approach is $O(n)$ which is much better. Then for the space complexity. Remember, space complexity takes any memory you use into account including the call stack. Thus, the space complexity of non-memoization approach is $O(n)$ (e.g. fib(6) - fib(5) - fib(4) - fib(3) - fib(2) - fib(1), the fib(6) has not called fib(4) yet) and it is the same for the memoization approach too (memory for record table). Down-Top TabulationDifferent from Memoization, tabulation solves the problem by starting from the most trivial subproblem, upwards to the top. Let’s look at an example to see how this works. Calculate the total number of possible path to the destination in the image Divide the Problem RecursivelyTo analyze this problem, the green guy can simply walk downwards or to the right (you know, it will be stupid to turn back (i.e. to the left and upwards)). Thus, we can divide this problem as separate steps along path as below.&emsp;&emsp;&emsp;$Path(start, end) = Path(A, end) + Path(B, end) = …$ Memoization vs. RecursionWe can see from the image above that Path(C, end) will be calculated twice and so are others, which is fairly inefficient. That is because there are overlapping between some subproblems. Thus we can take the Memoization approach to make sure each subproblem solved only once. To do this, we can use a table to record the total number of paths from a specific point to the end. Start by the Most Trivial ProblemDynamic Programming solves problem from down to top. This idea applies here as well. Instead of starting from the start point, we can think of this problem from the end point backwards.&emsp;&emsp;&emsp;$Path(P, end) = Path(P’s\ right, end) + Path(P’s\ down, end)$Thus, we can compute the whole table from the right to left and then down to up. SummaryIn a nutshell, dynamic programming is suitable for the situation where you can divide problem into sub-problems which can be broken down to smaller sub-problems and there is overlapping in solving the sub-problems. It is efficient by only computing the overlapping part once. Basically, optimization and combinatorial problems are of the two most typical problem of dynamic programming problems. The optimization problem requires you to find a feasible solution so that the objective function can be optimized while the combinatorial problems want you to compute the number of ways to do something or possibility of some event happening. Do note that similar to divide-and-conquer though it is, dynamic programming is better when there is overlapping between the subproblems while the divide-and-conquer doesn’t. Problem Number in LeetCode#53 (Maximum Subarray)#62 - #63 - #64 (Path Stuff)#70 (Climbing Stairs)#123 (Best time to buy and sell III)#174 (Dungeon Game) For boundary, can assign dp[m+1][n+1] instead of dp[m][n]#303 (Range Sum Query)#552 (Student Attendance Record II) Reference:&emsp;youtube - Algorithms: Memoization and Dynamic Programming&emsp;An intro to Algorithms: Dynamic Programming&emsp;Tutorial For Dynamic Programming]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS61B-2: Bits, Type, Lists, Sets]]></title>
    <url>%2F2019%2F07%2F06%2FCS61B-2-Bits-Type-Lists%2F</url>
    <content type="text"><![CDATA[Arrays have a fixed size ?Then come Lists ! BitsMemory is stored as a sequence of 0 and 1 and bits Interpreted using types Variable Types 8 primitive types: byte, short, int, long, float, double, char, boolean Reference Types Golden Rule of Equals x = y =&gt; copy the bits from y to x Parameter Passing =&gt; just copy the bits (pass by value always) Object Instantiation Declaring a Variable (primitive type)1. Set aside memory (Java will set aside exact bits to hold a thing of type)2. Create an entry in an internal table that maps variable name to the location of the first bit in the box by Java Interpreter☑️ Java does not write anything to reserved boxes when declaring variables (no default values)☑️ Java does not allow accessing a variable uninitialized Reference Variables declaration1. Allocate a box of 64 bits2. Address of instance returned by new operator and bits copied into boxNull == all zeros Using new keyword1. Allocates a box for each instance variable of the class and fills them with a default value.2. Constructor then usually fills every box with some other value(In real Java, there is additional overhead for any object) Arrays Instantiation Arrays Structure A fixed integer length N A sequence of N memory boxes where all boxes are of the same type (0 thru N - 1) Array Creation 123x = new int[3]; // each box filled a default value (e.g. 0) y = new int[]&#123;1, 2, 3, 4, 5&#125;; // specified starting valuesint[] z = &#123;9, 10 ,11, 12, 13&#125;; // declare and create z, omit new keyword (only used with declaration) Copy Array123//faster than copying item by item using loopSystem.arraycopy(srcArray, startPosInSrc, targetArray, startPosInTarget, lenToCopy)e.g System.arraycopy(b, 0, x, 3, 2); // b &#123;9, 10, 11&#125;, x &#123;1, 2, 3, 4, 5&#125; -&gt; &#123;1, 2, 3, 9, 10&#125; Java Arrays only perform bounds checking at runtime 2D Arrays – Array of Array References1234int[][] bamboozle = new int[4][]; // create an array of int arrays (4 memory boxes, each points to an array of int(unspecifid length)), only 1 array createdint[][] bamboozle = new int[4][4]; // create 5 arraysint[] rowZero = bamboozle[0];int[][] x = &#123; &#123;1, 2, 3&#125;, &#123;4, 5, 6&#125;, &#123;7, 8&#125; &#125;; Basic Int Linked List&emsp;Naked recursive data structure 1234567891011121314151617public class IntList &#123; public int first; public IntList rest; public IntList(int f, IntList r) &#123; first = f; rest = r; &#125; /** Return the size of the list using... recursion! */ public int size() &#123; if (rest == null) &#123; return 1; &#125; return 1 + this.rest.size(); &#125;&#125; Singly Linked List (SLList) Improvement #1: Rebranding &emsp;Rename IntList class to IntNode class Improvement #2: Bureaucracy &emsp;IntNode is hard to work with =&gt; create a separate class called SLList &emsp;SLList as a middle man between user &amp; naked recursive data structure Improvement #3: Public vs. Private &emsp;Declare first variable of SLList class as private &emsp;&emsp;=&gt; inaccessible naked data structure Improvement #4: Nested Classes &emsp;Embed a class declaration inside of another Static Nested classesWhen nested class never use any instance members of the outer class =&gt; can not access any of the members of the enclosing classSave small amount of memory Improvement #5: addLast(), size() and Caching Recursive Approach of size() Slow method for long list (scan thru the whole list) 1234567891011/** Returns the size of the list starting at IntNode p. */private static int size(IntNode p) &#123; if (p.next == null) &#123; return 1; &#125; return 1 + size(p.next);&#125;public int size() &#123; return size(first);&#125; OverLoaded Method Two methods with the same name but different signatures Caching Add a size variable to track the current size Increase memory usage and slow down add method Improvement #6: The Empty List&emsp;Constructor to create an empty list (first = null; size = 0)&emsp;&emsp;=&gt; addLast Null Pointer Excep&emsp;SLList with Sentinel Node Doubly Linked List (DLList) Limitations of SLList and FixLimitation and Reason =&gt; Slow method for long list (scan thru the whole list)Approach #1: add a last variable&emsp;Limitations: addLast () and getLast () will be fast but removeLast () will be&emsp;slow (to get second-to-last node) &emsp;&emsp; Approach #2: Looking Back – Doubly Linked List&emsp;&emsp; Add a previous pointer to each node, 2 links for each node &emsp;&emsp; Limitation: last pointer sometimes points at the sentinel node and sometimes a&emsp;&emsp; real node =&gt; getLast() method wrong Improvements: Sentinel UpgradeApproach #1: add a second sentinel node &emsp;&emsp; Approach #2: Circular List&emsp;&emsp; front and back pointer sharing the same sentinel node Generic Lists (e.g. DLLists) Limitations of the Above ListsThey can only hold integer values Generics Declaration Syntax123public class DLList&lt;T&gt; &#123; public T item;&#125; Instantiation Syntax 1DLList&lt;String&gt; d2 = new DLList&lt;&gt;(“hello”); Syntax Details ☑️Generics only work with reference type; ☑️Empty diamond operator can be used during instantiation if declaration happens at the same line (but can also declare the type inside of the angle brackets during instantiating) ArrayList Linked List Performance of get(i)Linear in the size of the entire listSlow for random access =&gt; use array instead Array ResizingApproach #1: add more size at once =&gt; slowApproach #2: multiply size by 2 (scaling factor) – Geometric Resizing Improvement: Spike of eventsUsage ratio = size of the list / length of the arrayHalf the size when ratio &lt; 0.25 Generic AList12Glorp[] items = new Glorp[8]; // Wrong! Generic Type cannot be instantiated directly !Glorp[] items = (Glorp[]) new Object[8]; // Right ! only a compilation warning Nulling out deleted items for generics objects to avoid loitering (Java only destroys (garbage collects) object when the last reference has been lost) List and Set in Real World ListInterface: java.util.ListImplementations: java.util.ArrayList, java.util.LinkedList SetSets – a collection of unique elements, no sense of orderInterface: java.util.SetImplementations: java.util.HashSet, java.util.TreeSet Reference:&emsp;berkeyley-cs61b]]></content>
      <categories>
        <category>CS61B</category>
        <category>Lecture Notes</category>
      </categories>
      <tags>
        <tag>Bits</tag>
        <tag>Type</tag>
        <tag>LinkedList</tag>
        <tag>ArrayList</tag>
        <tag>Set</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Knuth-Morris-Pratt(KMP) Algorithm]]></title>
    <url>%2F2019%2F07%2F06%2FKnuth-Morris-Pratt-KMP-Algorithm%2F</url>
    <content type="text"></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Big Data Analytics]]></title>
    <url>%2F2019%2F07%2F06%2FBig-Data-Analytics%2F</url>
    <content type="text"></content>
      <categories>
        <category>CC</category>
        <category>Big Data Analytics</category>
      </categories>
      <tags>
        <tag>sequential analytics</tag>
        <tag>MapReduce</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git: Local & Remote Repo]]></title>
    <url>%2F2019%2F07%2F06%2FGit-Local-Remote-Repo%2F</url>
    <content type="text"><![CDATA[Git &amp; Local Repos Version Control System&emsp;Track the history of code revision&emsp;Git is a distributed version control system&emsp;&emsp;&emsp;each developer’s computer store the entire history&emsp;Repository = entire history of an entire project Git Config12$ git config –global user.email “you@xxx.edu”$ git config -global user.name “your name” Local Repositories12345678$ cd to directory$ git init # tell the version control system that we want to track history of directory but nothing is stored in the repository at this point$ git add ./blahblah # store things in the repository, but still nothing stored yet, just add files to the list of files to track (you may not want to track all files in directories)$ git status # changes to be committed (list files trakced and whose changes ready to be committed) / untracked files$ git commit -m “add some stuffs” # stick copies of files into the repository / -m add message to the commit$ git log # see evidence of snapshot (commit ID)$ git show commitID # peek inside of the commit$ git checkout commitID filepath # roll back files but does not change the commit history / checkout auto does a git add on roll back files Local Repositories (Technical Overview) Initializing Local Repositories&emsp;Repositories: store files as well as history of changes to files&emsp;Initialize git repositories -&gt; create a .git subdirectory (store metadata as&emsp;well as old the actual snapshots of the files) Tracked vs Untracked Files&emsp;Tracked Files: been added to git repository&emsp;Untracked Files: never been tracked or removed from tracking (git not keep history) Staging &amp; Committing&emsp;commit =&gt; specific snapshot of working directory (users specify what composes the snapshot by staging file) Undoing Changes&emsp;Unstage a file1$ git reset HEAD [file] # unstage a file that you have not yet committed (leave changes intact) &emsp;Amend latest commit (change message or add forgotten files)12$ git add [forgotten-files]$ git commit –amend # This commit will replace previous commit &emsp;Revert a file to its state at the time of the most recent commit1$ git checkout -- [file] Git &amp; Remote Repo Remote Repositories&emsp;Store copies of your repositories on computers other than yours&emsp;By convention the name of the primary remote is called origin Remote Add12345$ git remote add [remote-repo-name] [remote-repo-URL] # record a new location for network data transfere.g. $ git remote add origin https://github.com/.......$ git remote rename [old-name] [new-name] # rename the repo$ git remote rm [remote-name] # remove the repo$ git remote -v # list all locations for network data transfer Cloning a Remote1$ git clone [remote-repo-URL] # make a copy of repository and record the URL of the remote repo for network data transfer and name it as origin Pushing Commits12$ git push [remote-name] [remote-branch] # push commits to GitHube.g. $ git push origin master Fetching &amp; Pulling Commits12$ git fetch [remote-name] # only update your local copy of the remote code but not merge the changes into your own code $ git pull [remote-repo-name] [remote-branch-name] # get the most recent copy of the files as seen in remote-repo-name (== fetch + merge, also merge the changes into your HEAD branch) Git Branching Intro&emsp;Branches =&gt; allow keeping track of multiple different versions of work&emsp;Git data structure is a graph (branch pointers and commits as nodes) Creating, Deleting &amp; Switching Branches&emsp;HEAD pointers references the branch you currently have and Branching&emsp;instructions modify branches and change what HEAD points to 12345$ git branch [new-branch-name] # create a branch off of your current branch$ git checkout [destination-branch] # switch branches$ git checkout -b [new-branch-name] # create a new branch and switch to it$ git branch -d [branch-to-delete] # delete a branch$ git branch -v # figure out which branch you are on Merging (Merge one branch into another) command12$ git checkout master $ git merge [other-branch-name]. # merge the other branch into master &emsp;this will create a new commit that joins two branches and change each pointer to this new commit / first parent–commit on the master branch / second parent–other branch Merge Conflicts and Resolving If commits on the two branches changed the same files (Sometimes conflict can not be resolve =&gt; will present both changes from the different branches) Git tells which files have conflict =&gt; open files =&gt; resolve manually =&gt; commit 2 segments of code&emsp;Top code snippet =&gt; branch originally had checked out when running merge command =&gt; called HEAD&emsp;Bottom code snippet =&gt; branch you were merging into your checked out branch Reference:&emsp;berkeyley-cs61b-lab1&emsp;git documentation]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS61B-1:Java Intro, Classes]]></title>
    <url>%2F2019%2F07%2F05%2FCS61B-1-Java-Intro-Classes%2F</url>
    <content type="text"><![CDATA[Running a Java Program .java-&gt; javac (compiler) -&gt; .class (Java bytecode) -&gt; java (Interpreter) -&gt; runs .class file 1. safer (type checked) 2. faster (for machine to execute) 3. protect intellectual property Static Typing Statically Typed language&emsp;All Variables have a declared type and type can never be changed&emsp;Expressions have a type&emsp;Compiler will check and make sure the type right before the program runs Pros and Cons Pros catch certain types of errors type errors never occur on end users easier to read and reason about the code run efficiently (no runtime type checking) Cons code is more verbose code is less general but it can be solved by generics Static vs. Non-Static Instance Variables and Object Instantiation&emsp;Problem: Not all objects of a class are equal&emsp;&emsp;=&gt; Approach1: create separate classes for each =&gt; redundancy&emsp;&emsp;=&gt; Approach2: classes instantiated and instances hold data&emsp;&emsp;&emsp;&emsp;e.g. Type ins = new Type();&emsp;Instance Members (Variables/Methods) = Non-Static Members (Variables/Methods) Constructors&emsp;Parameterized instantiation Class (Static) Methods VS Instance (Non-Static) Methods Static Methods&emsp;invoked using the class name Static Variables&emsp;properties inherent to class itself&emsp;accessed using name of class Instance Methods&emsp;actions that can be taken only by a specific instance of a class&emsp;Keyword this to refer to the current object Arrays of Object 2 steps of initializing arrays&emsp;=&gt; First use new keyword to create the array (Dog[] dogs = new Dog[2])&emsp;=&gt; then use new again for each object that you want to put into the array The array index starts at 0 in Java Array.length Alternate way of defining array&emsp;int[] numbers = new int[] {4, 7, 10}; Summary of Terminology Instance Variables (Properties) Non-static Methods (Instance Methods) Constructors (How to instantiate the class)Declaration + Instantiation + Assignment + Invocation of Methods Reference:&emsp;berkeyley-cs61b]]></content>
      <categories>
        <category>CS61B</category>
        <category>Lecture Notes</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Git</tag>
        <tag>Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F04%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Others</category>
      </categories>
  </entry>
</search>
